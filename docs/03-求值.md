# 第三章：求值

## 目录

- [3.1 求值简介](#31-求值简介)
- [3.2 对象系统](#32-对象系统)
- [3.3 环境和作用域](#33-环境和作用域)
- [3.4 实现求值器](#34-实现求值器)
- [3.5 求值表达式](#35-求值表达式)
- [3.6 函数和闭包](#36-函数和闭包)
- [3.7 内置函数](#37-内置函数)
- [3.8 错误处理](#38-错误处理)
- [3.9 完整示例](#39-完整示例)

## 3.1 求值简介

求值（Evaluation）是解释器的最后一步。它的任务是遍历 AST 并执行代码，产生实际的运行结果。

### 树遍历解释器

我们实现的是一个 **树遍历解释器（Tree-Walking Interpreter）**：递归遍历 AST 的每个节点，执行相应的操作，返回结果对象。

## 3.2 对象系统

在求值过程中，所有的值都被表示为 **对象（Object）**。

### MonkeyObject 接口

```typescript
export interface MonkeyObject {
  type(): ObjectType
  inspect(): string
}
```

### 对象类型

- `INTEGER_OBJ` - 整数
- `BOOLEAN_OBJ` - 布尔值
- `STRING_OBJ` - 字符串
- `NULL_OBJ` - 空值
- `RETURN_VALUE_OBJ` - 返回值包装
- `ERROR_OBJ` - 错误
- `FUNCTION_OBJ` - 函数
- `BUILTIN_OBJ` - 内置函数
- `ARRAY_OBJ` - 数组
- `HASH_OBJ` - 哈希表

### 基本类型对象

#### IntegerObject（整数）

```typescript
export class IntegerObject implements MonkeyObject {
  constructor(public value: number) {}

  type(): ObjectType {
    return INTEGER_OBJ
  }

  inspect(): string {
    return this.value.toString()
  }
}
```

#### BooleanObject（布尔值）

```typescript
export class BooleanObject implements MonkeyObject {
  constructor(public value: boolean) {}

  type(): ObjectType {
    return BOOLEAN_OBJ
  }

  inspect(): string {
    return this.value.toString()
  }
}
```

### 特殊类型对象

#### ReturnValue（返回值包装）

用于包装 return 语句的值，这样我们可以在遇到 return 时立即停止执行：

```typescript
export class ReturnValue implements MonkeyObject {
  constructor(public value: MonkeyObject) {}

  type(): ObjectType {
    return RETURN_VALUE_OBJ
  }

  inspect(): string {
    return this.value.inspect()
  }
}
```

### 函数对象

#### FunctionObject

```typescript
export class FunctionObject implements MonkeyObject {
  constructor(
    public parameters: Identifier[],
    public body: BlockStatement,
    public env: Environment // 闭包环境！
  ) {}

  type(): ObjectType {
    return FUNCTION_OBJ
  }
}
```

注意 `env` 字段：这是实现闭包的关键！函数会"记住"它定义时的环境。

## 3.3 环境和作用域

环境（Environment）用于存储和管理变量绑定，实现词法作用域。

### Environment 类

```typescript
export class Environment {
  private store: Map<string, MonkeyObject>
  private outer?: Environment

  constructor(outer?: Environment) {
    this.store = new Map()
    this.outer = outer
  }

  public get(name: string): [MonkeyObject | null, boolean] {
    let obj = this.store.get(name)
    if (obj !== undefined) {
      return [obj, true]
    }
    if (this.outer !== undefined) {
      return this.outer.get(name)
    }
    return [null, false]
  }

  public set(name: string, val: MonkeyObject): MonkeyObject {
    this.store.set(name, val)
    return val
  }
}
```

### 作用域链

环境形成一个链式结构，实现词法作用域。查找变量时，从当前环境开始，沿着 outer 链向上查找。

## 3.4 实现求值器

### 全局单例对象

```typescript
const NULL = new NullObject()
const TRUE = new BooleanObject(true)
const FALSE = new BooleanObject(false)
```

### 核心函数：evalNode

```typescript
export function evalNode(
  node: Node | null,
  env: Environment
): MonkeyObject | null {
  if (node === null) {
    return null
  }

  // 程序节点
  if (node instanceof Program) {
    return evalProgram(node, env)
  }

  // 表达式语句
  if (node instanceof ExpressionStatement) {
    return evalNode(node.expression, env)
  }

  // let语句
  if (node instanceof LetStatement) {
    const val = evalNode(node.value, env)
    if (isError(val)) {
      return val
    }
    env.set(node.name.value, val!)
    return val
  }

  // 整数字面量
  if (node instanceof IntegerLiteral) {
    return new IntegerObject(node.value)
  }

  // 中缀表达式
  if (node instanceof InfixExpression) {
    const left = evalNode(node.left, env)
    if (isError(left)) return left

    const right = evalNode(node.right, env)
    if (isError(right)) return right

    return evalInfixExpression(node.operator, left!, right!)
  }

  // 函数字面量
  if (node instanceof FunctionLiteral) {
    return new FunctionObject(node.parameters, node.body, env)
  }

  // 函数调用
  if (node instanceof CallExpression) {
    const func = evalNode(node.func, env)
    if (isError(func)) return func

    const args = evalExpressions(node.args, env)
    if (args.length === 1 && isError(args[0])) {
      return args[0]
    }

    return applyFunction(func!, args)
  }

  return null
}
```

## 3.5 求值表达式

### 求值中缀表达式

```typescript
function evalInfixExpression(
  operator: string,
  left: MonkeyObject,
  right: MonkeyObject
): MonkeyObject {
  // 整数运算
  if (left.type() === INTEGER_OBJ && right.type() === INTEGER_OBJ) {
    return evalIntegerInfixExpression(operator, left, right)
  }

  // 字符串连接
  if (left.type() === STRING_OBJ && right.type() === STRING_OBJ) {
    return evalStringInfixExpression(operator, left, right)
  }

  // 相等性比较
  if (operator === '==') {
    return nativeBoolToBooleanObject(left === right)
  }
  if (operator === '!=') {
    return nativeBoolToBooleanObject(left !== right)
  }

  return newError(
    `unknown operator: ${left.type()} ${operator} ${right.type()}`
  )
}
```

### 求值 if 表达式

```typescript
function evalIfExpression(
  ie: IfExpression,
  env: Environment
): MonkeyObject | null {
  const condition = evalNode(ie.condition, env)
  if (isError(condition)) {
    return condition
  }

  if (isTruthy(condition!)) {
    return evalNode(ie.consequence, env)
  } else if (ie.alternative) {
    return evalNode(ie.alternative, env)
  } else {
    return NULL
  }
}
```

## 3.6 函数和闭包

### 求值函数调用

```typescript
function applyFunction(func: MonkeyObject, args: MonkeyObject[]): MonkeyObject {
  // 用户定义的函数
  if (func.type() === FUNCTION_OBJ) {
    const funcObj = func as FunctionObject
    const extendedEnv = extendFunctionEnv(funcObj, args)
    const evaluated = evalNode(funcObj.body, extendedEnv)
    return unwrapReturnValue(evaluated)
  }

  // 内置函数
  if (func.type() === BUILTIN_OBJ) {
    const builtinObj = func as BuiltinObject
    return builtinObj.fn(...args)
  }

  return newError(`not a function: ${func.type()}`)
}
```

### 扩展函数环境

```typescript
function extendFunctionEnv(
  func: FunctionObject,
  args: MonkeyObject[]
): Environment {
  const env = newEnclosedEnvironment(func.env)

  for (let i = 0; i < func.parameters.length; i++) {
    env.set(func.parameters[i].value, args[i])
  }

  return env
}
```

### 闭包示例

```monkey
let newAdder = fn(x) {
  fn(y) { x + y };
};

let addTwo = newAdder(2);
addTwo(3); // 5
```

工作原理：

1. `newAdder` 被调用，参数 `x = 2`
2. 创建内层函数时，它捕获了包含 `x = 2` 的环境
3. 返回的函数"记住"了 `x` 的值
4. 调用 `addTwo(3)` 时，它可以访问 `x = 2` 和 `y = 3`

## 3.7 内置函数

### 定义内置函数

```typescript
export const builtins = new Map<string, BuiltinObject>([
  // len: 获取长度
  [
    'len',
    new BuiltinObject((...args: MonkeyObject[]): MonkeyObject => {
      if (args.length !== 1) {
        return new ErrorObject(`wrong number of arguments`)
      }

      const arg = args[0]
      if (arg instanceof StringObject) {
        return new IntegerObject(arg.value.length)
      }
      if (arg instanceof ArrayObject) {
        return new IntegerObject(arg.elements.length)
      }

      return new ErrorObject(`argument to 'len' not supported`)
    }),
  ],

  // first: 获取数组第一个元素
  [
    'first',
    new BuiltinObject((...args: MonkeyObject[]): MonkeyObject => {
      if (args.length !== 1 || args[0].type() !== ARRAY_OBJ) {
        return new ErrorObject(`invalid argument`)
      }

      const arr = args[0] as ArrayObject
      return arr.elements.length > 0 ? arr.elements[0] : new NullObject()
    }),
  ],

  // puts: 打印输出
  [
    'puts',
    new BuiltinObject((...args: MonkeyObject[]): MonkeyObject => {
      for (const arg of args) {
        console.log(arg.inspect())
      }
      return new NullObject()
    }),
  ],
])
```

## 3.8 错误处理

### 创建和传播错误

```typescript
function newError(message: string): ErrorObject {
  return new ErrorObject(message)
}

function isError(objValue: MonkeyObject | null): boolean {
  return objValue !== null && objValue.type() === ERROR_OBJ
}
```

一旦产生错误，立即停止执行并向上传播。

## 3.9 完整示例

### 示例 1：基本运算

```typescript
const input = `
let x = 5;
let y = 10;
let result = x + y * 2;
result;
`

const lexer = new Lexer(input)
const parser = new Parser(lexer)
const program = parser.parseProgram()
const env = new Environment()
const result = evalNode(program, env)

console.log(result?.inspect()) // "25"
```

### 示例 2：递归函数

```typescript
const input = `
let fibonacci = fn(n) {
  if (n < 2) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
};

fibonacci(10);
`

const result = evalNode(program, env)
console.log(result?.inspect()) // "55"
```

### 示例 3：高阶函数

```typescript
const input = `
let map = fn(arr, f) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      accumulated
    } else {
      iter(rest(arr), push(accumulated, f(first(arr))))
    }
  };
  iter(arr, []);
};

let double = fn(x) { x * 2 };
map([1, 2, 3, 4], double);
`

console.log(result?.inspect()) // "[2, 4, 6, 8]"
```

## 小结

在本章中，我们学习了：

1. **对象系统**：基本类型、特殊类型、函数类型、复合类型
2. **环境和作用域**：变量存储和查找、词法作用域、作用域链
3. **求值器实现**：递归遍历 AST、求值语句和表达式、错误处理
4. **函数和闭包**：函数作为一等公民、闭包的实现、高阶函数
5. **内置函数**：实现常用的内置函数

现在我们有了一个功能完整的解释器！

---

**上一章**：[第二章：语法分析](./02-parsing.md)

**下一章**：[第四章：扩展解释器](./04-extending.md)

**源代码参考**：

- [object.ts](../src/monkey/object/object.ts)
- [environment.ts](../src/monkey/object/environment.ts)
- [evaluator.ts](../src/monkey/evaluator/evaluator.ts)
- [builtins.ts](../src/monkey/evaluator/builtins.ts)
