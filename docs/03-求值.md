# 第三章：求值

> "程序的意义就是它的执行。" —— Programming Language Foundations

## 目录

- [3.1 求值简介](#31-求值简介)
  - [3.1.1 什么是求值](#311-什么是求值)
  - [3.1.2 从 AST 到运行时对象](#312-从-ast-到运行时对象)
  - [3.1.3 求值器的职责](#313-求值器的职责)
- [3.2 运行时对象系统](#32-运行时对象系统)
  - [3.2.1 为什么需要对象系统](#321-为什么需要对象系统)
  - [3.2.2 对象类型设计](#322-对象类型设计)
  - [3.2.3 基本类型对象](#323-基本类型对象)
  - [3.2.4 复合类型对象](#324-复合类型对象)
  - [3.2.5 特殊对象](#325-特殊对象)
- [3.3 环境和作用域](#33-环境和作用域)
  - [3.3.1 什么是环境](#331-什么是环境)
  - [3.3.2 词法作用域](#332-词法作用域)
  - [3.3.3 闭包的实现](#333-闭包的实现)
- [3.4 求值器实现](#34-求值器实现)
  - [3.4.1 求值器的核心结构](#341-求值器的核心结构)
  - [3.4.2 求值语句](#342-求值语句)
  - [3.4.3 求值表达式](#343-求值表达式)
  - [3.4.4 求值字面量](#344-求值字面量)
  - [3.4.5 求值运算符](#345-求值运算符)
  - [3.4.6 求值函数调用](#346-求值函数调用)
- [3.5 错误处理](#35-错误处理)
- [3.6 内置函数](#36-内置函数)
- [3.7 完整示例](#37-完整示例)
- [3.8 测试策略](#38-测试策略)
- [3.9 性能优化](#39-性能优化)

---

## 3.1 求值简介

### 3.1.1 什么是求值

**求值（Evaluation）** 是解释器的核心步骤，它将抽象语法树（AST）转换为实际的运行时值。这个过程也被称为**解释执行（Interpretation）**或**运行时执行（Runtime Execution）**。

#### 类比理解

想象你正在按照食谱做菜：

```
食谱（源代码）
  ↓ 词法分析
Token 流（食材列表）
  ↓ 语法分析
AST（结构化的制作步骤）
  ↓ 求值
真正的食物（运行时结果）
```

### 3.1.2 从 AST 到运行时对象

让我们看一个具体的转换过程：

#### 输入（AST）

```typescript
Program {
  statements: [
    LetStatement {
      name: Identifier("x"),
      value: InfixExpression {
        left: IntegerLiteral(5),
        operator: "+",
        right: IntegerLiteral(3)
      }
    },
    ExpressionStatement {
      expression: Identifier("x")
    }
  ]
}
```

#### 执行过程

```
1. 创建全局环境

2. 求值 LetStatement:
   - 求值右侧表达式: 5 + 3
     - 求值 5 → IntegerObject(5)
     - 求值 3 → IntegerObject(3)
     - 应用 + 运算 → IntegerObject(8)
   - 将 x → IntegerObject(8) 存入环境

3. 求值 ExpressionStatement:
   - 求值 Identifier("x")
   - 从环境中查找 x
   - 返回 IntegerObject(8)
```

#### 输出（运行时对象）

```typescript
IntegerObject { value: 8 }
```

### 3.1.3 求值器的职责

求值器有以下核心职责：

#### 1. **遍历 AST**

递归地访问每个节点并计算其值。

```typescript
function evalNode(node: Node, env: Environment): MonkeyObject {
  if (node instanceof IntegerLiteral) {
    return new IntegerObject(node.value)
  }
  if (node instanceof InfixExpression) {
    const left = evalNode(node.left, env)
    const right = evalNode(node.right, env)
    return applyInfixOperator(node.operator, left, right)
  }
  // ...
}
```

#### 2. **管理环境**

维护变量绑定和作用域。

```monkey
let x = 5;        // 在环境中创建绑定: x → 5
let y = x + 3;    // 查找 x 的值，计算，创建新绑定: y → 8
```

#### 3. **处理控制流**

执行条件判断、函数调用、返回语句等。

```monkey
if (x > 5) {
  return true;
} else {
  return false;
}
```

#### 4. **错误处理**

检测并报告运行时错误。

```monkey
5 + "hello"  // 类型错误
arr[100]     // 索引越界
```

## 3.2 运行时对象系统

### 3.2.1 为什么需要对象系统

在解释器中，我们需要一个统一的方式来表示**运行时的值**。这些值可能是整数、字符串、函数、数组等等。

#### AST 节点 vs 运行时对象

```
AST 节点（编译时）     运行时对象（运行时）
─────────────────     ─────────────────
IntegerLiteral(5)  →  IntegerObject(5)
StringLiteral("hi") → StringObject("hi")
FunctionLiteral     →  FunctionObject
```

**关键区别：**

- **AST 节点**：表示代码的结构，包含语法信息
- **运行时对象**：表示实际的值，可以参与计算

### 3.2.2 对象类型设计

#### 基础接口

```typescript
/**
 * MonkeyObject 接口
 *
 * 所有运行时对象的基础接口
 */
export interface MonkeyObject {
  /**
   * 返回对象的类型
   */
  type(): ObjectType

  /**
   * 返回对象的字符串表示
   */
  inspect(): string
}
```

#### 对象类型枚举

```typescript
/**
 * ObjectType 类型
 *
 * 定义所有可能的对象类型
 */
export type ObjectType = string

// 基本类型
export const INTEGER_OBJ = 'INTEGER'
export const BOOLEAN_OBJ = 'BOOLEAN'
export const STRING_OBJ = 'STRING'
export const NULL_OBJ = 'NULL'

// 复合类型
export const ARRAY_OBJ = 'ARRAY'
export const HASH_OBJ = 'HASH'

// 函数类型
export const FUNCTION_OBJ = 'FUNCTION'
export const BUILTIN_OBJ = 'BUILTIN'

// 特殊类型
export const RETURN_VALUE_OBJ = 'RETURN_VALUE'
export const ERROR_OBJ = 'ERROR'
```

### 3.2.3 基本类型对象

#### IntegerObject（整数对象）

```typescript
/**
 * IntegerObject 类
 *
 * 表示整数值
 */
export class IntegerObject implements MonkeyObject {
  value: number

  constructor(value: number) {
    this.value = value
  }

  type(): ObjectType {
    return INTEGER_OBJ
  }

  inspect(): string {
    return this.value.toString()
  }
}
```

**示例：**

```monkey
let x = 42;
// 运行时: IntegerObject { value: 42 }

let y = x + 8;
// 运行时: IntegerObject { value: 50 }
```

#### BooleanObject（布尔对象）

```typescript
/**
 * BooleanObject 类
 *
 * 表示布尔值
 */
export class BooleanObject implements MonkeyObject {
  value: boolean

  constructor(value: boolean) {
    this.value = value
  }

  type(): ObjectType {
    return BOOLEAN_OBJ
  }

  inspect(): string {
    return this.value.toString()
  }
}
```

**单例优化：**

```typescript
// 布尔值只有两个，使用单例避免重复创建
export const TRUE = new BooleanObject(true)
export const FALSE = new BooleanObject(false)

// 使用时
function nativeBoolToBooleanObject(value: boolean): BooleanObject {
  return value ? TRUE : FALSE
}
```

#### NullObject（空值对象）

```typescript
/**
 * NullObject 类
 *
 * 表示空值/无值
 */
export class NullObject implements MonkeyObject {
  type(): ObjectType {
    return NULL_OBJ
  }

  inspect(): string {
    return 'null'
  }
}

// 单例
export const NULL = new NullObject()
```

#### StringObject（字符串对象）

```typescript
/**
 * StringObject 类
 *
 * 表示字符串值
 */
export class StringObject implements MonkeyObject {
  value: string

  constructor(value: string) {
    this.value = value
  }

  type(): ObjectType {
    return STRING_OBJ
  }

  inspect(): string {
    return this.value
  }
}
```

### 3.2.4 复合类型对象

#### ArrayObject（数组对象）

```typescript
/**
 * ArrayObject 类
 *
 * 表示数组，可以包含任意类型的元素
 */
export class ArrayObject implements MonkeyObject {
  elements: MonkeyObject[]

  constructor(elements: MonkeyObject[]) {
    this.elements = elements
  }

  type(): ObjectType {
    return ARRAY_OBJ
  }

  inspect(): string {
    const elements = this.elements.map((e) => e.inspect()).join(', ')
    return `[${elements}]`
  }
}
```

**示例：**

```monkey
let arr = [1, "hello", true];
// 运行时: ArrayObject {
//   elements: [
//     IntegerObject(1),
//     StringObject("hello"),
//     BooleanObject(true)
//   ]
// }
```

#### HashObject（哈希对象）

哈希对象的实现比较复杂，因为需要处理键的比较。

```typescript
/**
 * Hashable 接口
 *
 * 可以作为哈希键的对象必须实现此接口
 */
export interface Hashable {
  hashKey(): HashKey
}

/**
 * HashKey 类
 *
 * 用于哈希表的键
 */
export class HashKey {
  type: ObjectType
  value: number | string

  constructor(type: ObjectType, value: number | string) {
    this.type = type
    this.value = value
  }
}

/**
 * HashPair 类
 *
 * 哈希表中的键值对
 */
export class HashPair {
  key: MonkeyObject
  value: MonkeyObject

  constructor(key: MonkeyObject, value: MonkeyObject) {
    this.key = key
    this.value = value
  }
}

/**
 * HashObject 类
 *
 * 表示哈希表（关联数组）
 */
export class HashObject implements MonkeyObject {
  pairs: Map<string, HashPair>

  constructor(pairs: Map<string, HashPair>) {
    this.pairs = pairs
  }

  type(): ObjectType {
    return HASH_OBJ
  }

  inspect(): string {
    const pairs: string[] = []
    for (const pair of this.pairs.values()) {
      pairs.push(`${pair.key.inspect()}: ${pair.value.inspect()}`)
    }
    return `{${pairs.join(', ')}}`
  }
}
```

**为什么需要 HashKey？**

JavaScript 的 Map 只能用字符串或对象作为键，但是：

```monkey
// 这两个应该是同一个键
{5: "five"}
{5: "FIVE"}

// 但如果直接用 IntegerObject 作为键，它们是不同的对象引用
// 所以我们需要 hashKey() 方法生成唯一标识
```

**实现 Hashable：**

```typescript
export class IntegerObject implements MonkeyObject, Hashable {
  // ...

  hashKey(): HashKey {
    return new HashKey(INTEGER_OBJ, this.value)
  }
}

export class StringObject implements MonkeyObject, Hashable {
  // ...

  hashKey(): HashKey {
    return new HashKey(STRING_OBJ, this.value)
  }
}

export class BooleanObject implements MonkeyObject, Hashable {
  // ...

  hashKey(): HashKey {
    const value = this.value ? 1 : 0
    return new HashKey(BOOLEAN_OBJ, value)
  }
}
```

**使用示例：**

```monkey
let hash = {"name": "Monkey", "age": 1, 5: "five"};
// 运行时: HashObject {
//   pairs: Map {
//     "STRING:name" => HashPair {
//       key: StringObject("name"),
//       value: StringObject("Monkey")
//     },
//     "STRING:age" => HashPair {
//       key: StringObject("age"),
//       value: IntegerObject(1)
//     },
//     "INTEGER:5" => HashPair {
//       key: IntegerObject(5),
//       value: StringObject("five")
//     }
//   }
// }
```

### 3.2.5 特殊对象

#### FunctionObject（函数对象）

```typescript
/**
 * FunctionObject 类
 *
 * 表示用户定义的函数
 * 包含参数列表、函数体和闭包环境
 */
export class FunctionObject implements MonkeyObject {
  parameters: Identifier[] // 参数列表
  body: BlockStatement // 函数体
  env: Environment // 闭包环境

  constructor(
    parameters: Identifier[],
    body: BlockStatement,
    env: Environment
  ) {
    this.parameters = parameters
    this.body = body
    this.env = env
  }

  type(): ObjectType {
    return FUNCTION_OBJ
  }

  inspect(): string {
    const params = this.parameters.map((p) => p.toString()).join(', ')
    return `fn(${params}) {\n${this.body.toString()}\n}`
  }
}
```

**为什么需要保存环境？**

这是实现**闭包（Closure）**的关键：

```monkey
let newAdder = fn(x) {
  fn(y) { x + y };  // 内部函数捕获了外部的 x
};

let addTwo = newAdder(2);
addTwo(3);  // 返回 5，因为 x = 2 被保存在闭包中
```

#### BuiltinObject（内置函数对象）

```typescript
/**
 * BuiltinFunction 类型
 *
 * 内置函数的签名
 */
export type BuiltinFunction = (...args: MonkeyObject[]) => MonkeyObject

/**
 * BuiltinObject 类
 *
 * 表示内置函数（用 TypeScript 实现）
 */
export class BuiltinObject implements MonkeyObject {
  fn: BuiltinFunction

  constructor(fn: BuiltinFunction) {
    this.fn = fn
  }

  type(): ObjectType {
    return BUILTIN_OBJ
  }

  inspect(): string {
    return 'builtin function'
  }
}
```

**示例：**

```typescript
// len 函数的实现
const lenBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  const arg = args[0]

  if (arg instanceof StringObject) {
    return new IntegerObject(arg.value.length)
  }
  if (arg instanceof ArrayObject) {
    return new IntegerObject(arg.elements.length)
  }

  return new ErrorObject(`argument to 'len' not supported, got ${arg.type()}`)
})
```

#### ReturnValue（返回值对象）

```typescript
/**
 * ReturnValue 类
 *
 * 包装返回值，用于在求值过程中传递返回语句的值
 */
export class ReturnValue implements MonkeyObject {
  value: MonkeyObject

  constructor(value: MonkeyObject) {
    this.value = value
  }

  type(): ObjectType {
    return RETURN_VALUE_OBJ
  }

  inspect(): string {
    return this.value.inspect()
  }
}
```

**为什么需要包装？**

```monkey
fn(x) {
  if (x > 5) {
    return 10;  // 需要从 if 代码块中冒泡出来
  }
  return 5;
}
```

如果直接返回 `IntegerObject(10)`，无法区分它是普通值还是 return 语句的结果。使用 `ReturnValue` 包装后，可以在求值过程中识别并提前返回。

#### ErrorObject（错误对象）

```typescript
/**
 * ErrorObject 类
 *
 * 表示运行时错误
 */
export class ErrorObject implements MonkeyObject {
  message: string

  constructor(message: string) {
    this.message = message
  }

  type(): ObjectType {
    return ERROR_OBJ
  }

  inspect(): string {
    return `ERROR: ${this.message}`
  }
}
```

**错误传播：**

```typescript
// 一旦产生错误，就停止求值并返回错误对象
if (left instanceof ErrorObject) {
  return left
}
if (right instanceof ErrorObject) {
  return right
}
```

## 3.3 环境和作用域

### 3.3.1 什么是环境

**环境（Environment）**是变量名到值的映射，用于实现变量的存储和查找。

```monkey
let x = 5;     // 在环境中存储: x → IntegerObject(5)
let y = x + 3; // 从环境中查找 x，得到 5，计算后存储: y → IntegerObject(8)
```

#### 环境的实现

```typescript
/**
 * Environment 类
 *
 * 管理变量绑定和作用域
 */
export class Environment {
  // 存储变量绑定的 Map
  private store: Map<string, MonkeyObject>

  // 外层环境（用于实现嵌套作用域）
  private outer: Environment | undefined

  constructor(outer?: Environment) {
    this.store = new Map()
    this.outer = outer
  }

  /**
   * 获取变量的值
   *
   * 先在当前环境查找，如果找不到则在外层环境查找
   */
  get(name: string): MonkeyObject | undefined {
    let obj = this.store.get(name)

    // 如果当前环境没有，尝试在外层环境查找
    if (obj === undefined && this.outer !== undefined) {
      obj = this.outer.get(name)
    }

    return obj
  }

  /**
   * 设置变量的值
   *
   * 总是在当前环境中设置
   */
  set(name: string, val: MonkeyObject): MonkeyObject {
    this.store.set(name, val)
    return val
  }
}

/**
 * 创建一个新的封闭环境
 *
 * 用于函数调用和代码块
 */
export function newEnclosedEnvironment(outer: Environment): Environment {
  return new Environment(outer)
}
```

### 3.3.2 词法作用域

**词法作用域（Lexical Scope）**也称为静态作用域，意味着变量的作用域在代码编写时就确定了。

#### 示例 1：基本作用域

```monkey
let x = 5;

if (true) {
  let y = 10;
  x + y;  // x 来自外层，y 来自当前层
}

y;  // 错误：y 在这里不可见
```

**环境链：**

```
全局环境: { x: 5 }
    ↑
if 环境: { y: 10 }
```

当查找 `x` 时：

1. 在 if 环境中查找 → 没找到
2. 在外层（全局）环境中查找 → 找到 x = 5

#### 示例 2：嵌套函数

```monkey
let x = 10;

let outer = fn() {
  let x = 20;

  let inner = fn() {
    x;  // 访问外层函数的 x (20)
  };

  inner();
};

outer();
```

**环境链：**

```
全局环境: { x: 10, outer: <function> }
    ↑
outer 函数环境: { x: 20, inner: <function> }
    ↑
inner 函数环境: {}  (空，但可以访问外层的 x)
```

### 3.3.3 闭包的实现

**闭包（Closure）**是函数和其词法环境的组合。当函数捕获了外部变量时，即使外部函数已经返回，这些变量仍然可以访问。

#### 经典闭包示例

```monkey
let newAdder = fn(x) {
  fn(y) { x + y };
};

let addTwo = newAdder(2);
addTwo(3);  // 返回 5
```

**执行过程：**

```
1. 调用 newAdder(2)
   ├── 创建新环境 E1: { x: 2 }
   ├── 求值函数体: fn(y) { x + y }
   ├── 创建 FunctionObject
   │   ├── parameters: [y]
   │   ├── body: { x + y }
   │   └── env: E1  ← 关键：保存当前环境！
   └── 返回 FunctionObject

2. addTwo 现在是 FunctionObject { ..., env: E1 }

3. 调用 addTwo(3)
   ├── 创建新环境 E2，outer = E1
   │   E2: { y: 3 }
   │       ↑
   │   E1: { x: 2 }
   ├── 在 E2 中求值 x + y
   │   ├── 查找 x: E2 没有 → E1 有 → 2
   │   ├── 查找 y: E2 有 → 3
   │   └── 计算 2 + 3 = 5
   └── 返回 IntegerObject(5)
```

**关键点：**

```typescript
// 创建函数对象时，保存当前环境
const func = new FunctionObject(
  funcLit.parameters,
  funcLit.body,
  env // ← 当前环境被"闭包"进来
)

// 调用函数时，使用保存的环境作为外层环境
const extendedEnv = newEnclosedEnvironment(func.env)
```

## 3.4 求值器实现

### 3.4.1 求值器的核心结构

```typescript
/**
 * evalNode 函数
 *
 * 求值器的核心函数
 * 根据节点类型分派到相应的求值函数
 *
 * @param node - 要求值的 AST 节点
 * @param env - 当前环境
 * @returns 求值结果
 */
export function evalNode(
  node: Node | null,
  env: Environment
): MonkeyObject | null {
  if (node === null) {
    return null
  }

  // 程序节点
  if (node instanceof Program) {
    return evalProgram(node, env)
  }

  // 语句节点
  if (node instanceof LetStatement) {
    return evalLetStatement(node, env)
  }
  if (node instanceof ReturnStatement) {
    return evalReturnStatement(node, env)
  }
  if (node instanceof ExpressionStatement) {
    return evalNode(node.expression, env)
  }
  if (node instanceof BlockStatement) {
    return evalBlockStatement(node, env)
  }

  // 表达式节点
  if (node instanceof IntegerLiteral) {
    return new IntegerObject(node.value)
  }
  if (node instanceof StringLiteral) {
    return new StringObject(node.value)
  }
  if (node instanceof BooleanLiteral) {
    return nativeBoolToBooleanObject(node.value)
  }
  if (node instanceof PrefixExpression) {
    return evalPrefixExpression(node, env)
  }
  if (node instanceof InfixExpression) {
    return evalInfixExpression(node, env)
  }
  if (node instanceof IfExpression) {
    return evalIfExpression(node, env)
  }
  if (node instanceof Identifier) {
    return evalIdentifier(node, env)
  }
  if (node instanceof FunctionLiteral) {
    return evalFunctionLiteral(node, env)
  }
  if (node instanceof CallExpression) {
    return evalCallExpression(node, env)
  }
  if (node instanceof ArrayLiteral) {
    return evalArrayLiteral(node, env)
  }
  if (node instanceof IndexExpression) {
    return evalIndexExpression(node, env)
  }
  if (node instanceof HashLiteral) {
    return evalHashLiteral(node, env)
  }

  return null
}
```

### 3.4.2 求值语句

#### 求值程序

```typescript
/**
 * 求值程序
 *
 * 依次求值所有语句，返回最后一个语句的值
 */
function evalProgram(program: Program, env: Environment): MonkeyObject | null {
  let result: MonkeyObject | null = null

  for (const statement of program.statements) {
    result = evalNode(statement, env)

    // 如果遇到 return 语句，立即返回（解包 ReturnValue）
    if (result instanceof ReturnValue) {
      return result.value
    }

    // 如果遇到错误，立即返回
    if (result instanceof ErrorObject) {
      return result
    }
  }

  return result
}
```

#### 求值 let 语句

```typescript
/**
 * 求值 let 语句
 *
 * 求值右侧表达式，然后在环境中创建绑定
 */
function evalLetStatement(
  stmt: LetStatement,
  env: Environment
): MonkeyObject | null {
  // 求值右侧表达式
  const val = evalNode(stmt.value, env)
  if (isError(val)) {
    return val
  }

  // 在环境中设置变量
  if (val !== null) {
    env.set(stmt.name.value, val)
  }

  return val
}
```

**执行示例：**

```monkey
let x = 5 + 3;
```

```
1. evalLetStatement
2. 求值 5 + 3
   ├── evalInfixExpression
   ├── evalNode(5) → IntegerObject(5)
   ├── evalNode(3) → IntegerObject(3)
   └── 5 + 3 → IntegerObject(8)
3. env.set('x', IntegerObject(8))
4. 返回 IntegerObject(8)
```

#### 求值 return 语句

```typescript
/**
 * 求值 return 语句
 *
 * 求值返回值表达式，并用 ReturnValue 包装
 */
function evalReturnStatement(
  stmt: ReturnStatement,
  env: Environment
): MonkeyObject | null {
  const val = evalNode(stmt.returnValue, env)
  if (isError(val)) {
    return val
  }

  // 用 ReturnValue 包装，以便在代码块中识别
  return val ? new ReturnValue(val) : null
}
```

#### 求值代码块

```typescript
/**
 * 求值代码块
 *
 * 依次求值所有语句
 * 如果遇到 return，停止并返回（保持 ReturnValue 包装）
 */
function evalBlockStatement(
  block: BlockStatement,
  env: Environment
): MonkeyObject | null {
  let result: MonkeyObject | null = null

  for (const statement of block.statements) {
    result = evalNode(statement, env)

    // 遇到 return 或错误，立即停止（不解包）
    if (result !== null) {
      const rt = result.type()
      if (rt === RETURN_VALUE_OBJ || rt === ERROR_OBJ) {
        return result
      }
    }
  }

  return result
}
```

**为什么不解包 ReturnValue？**

```monkey
fn(x) {
  if (x > 5) {
    return 10;  // evalBlockStatement 返回 ReturnValue(10)
  }              // ↓
  return 5;      // evalBlockStatement 检测到 ReturnValue，立即返回
}                // 不会执行到这里
```

### 3.4.3 求值表达式

#### 求值标识符

```typescript
/**
 * 求值标识符
 *
 * 从环境中查找变量的值
 */
function evalIdentifier(node: Identifier, env: Environment): MonkeyObject {
  // 先查找变量
  const val = env.get(node.value)
  if (val !== undefined) {
    return val
  }

  // 再查找内置函数
  const builtin = builtins.get(node.value)
  if (builtin !== undefined) {
    return builtin
  }

  // 都没找到，返回错误
  return new ErrorObject(`identifier not found: ${node.value}`)
}
```

### 3.4.4 求值字面量

#### 求值数组字面量

```typescript
/**
 * 求值数组字面量
 *
 * 依次求值所有元素
 */
function evalArrayLiteral(node: ArrayLiteral, env: Environment): MonkeyObject {
  const elements = evalExpressions(node.elements, env)

  // 检查是否有错误
  if (elements.length === 1 && isError(elements[0])) {
    return elements[0]
  }

  return new ArrayObject(elements)
}

/**
 * 求值表达式列表
 *
 * 用于数组元素、函数参数等
 */
function evalExpressions(exps: Expression[], env: Environment): MonkeyObject[] {
  const result: MonkeyObject[] = []

  for (const exp of exps) {
    const evaluated = evalNode(exp, env)
    if (isError(evaluated)) {
      return [evaluated!] // 遇到错误，立即返回
    }
    if (evaluated !== null) {
      result.push(evaluated)
    }
  }

  return result
}
```

#### 求值哈希字面量

```typescript
/**
 * 求值哈希字面量
 */
function evalHashLiteral(node: HashLiteral, env: Environment): MonkeyObject {
  const pairs = new Map<string, HashPair>()

  for (const [keyNode, valueNode] of node.pairs) {
    // 求值键
    const key = evalNode(keyNode, env)
    if (isError(key)) {
      return key!
    }

    // 检查键是否可哈希
    if (!isHashable(key)) {
      return new ErrorObject(`unusable as hash key: ${key!.type()}`)
    }

    // 求值值
    const value = evalNode(valueNode, env)
    if (isError(value)) {
      return value!
    }

    // 生成哈希键
    const hashKey = (key as Hashable).hashKey()
    const hashKeyStr = `${hashKey.type}:${hashKey.value}`

    // 存储键值对
    pairs.set(hashKeyStr, new HashPair(key!, value!))
  }

  return new HashObject(pairs)
}
```

### 3.4.5 求值运算符

#### 求值前缀表达式

```typescript
/**
 * 求值前缀表达式
 */
function evalPrefixExpression(
  node: PrefixExpression,
  env: Environment
): MonkeyObject {
  // 求值右侧操作数
  const right = evalNode(node.right, env)
  if (isError(right)) {
    return right!
  }

  // 根据运算符分派
  switch (node.operator) {
    case '!':
      return evalBangOperatorExpression(right!)
    case '-':
      return evalMinusPrefixOperatorExpression(right!)
    default:
      return new ErrorObject(
        `unknown operator: ${node.operator}${right!.type()}`
      )
  }
}

/**
 * 求值逻辑非运算符
 */
function evalBangOperatorExpression(right: MonkeyObject): MonkeyObject {
  if (right === TRUE) {
    return FALSE
  }
  if (right === FALSE) {
    return TRUE
  }
  if (right === NULL) {
    return TRUE
  }
  // 其他值都是 truthy
  return FALSE
}

/**
 * 求值负号运算符
 */
function evalMinusPrefixOperatorExpression(right: MonkeyObject): MonkeyObject {
  if (right.type() !== INTEGER_OBJ) {
    return new ErrorObject(`unknown operator: -${right.type()}`)
  }

  const value = (right as IntegerObject).value
  return new IntegerObject(-value)
}
```

#### 求值中缀表达式

```typescript
/**
 * 求值中缀表达式
 */
function evalInfixExpression(
  node: InfixExpression,
  env: Environment
): MonkeyObject {
  // 求值左侧操作数
  const left = evalNode(node.left, env)
  if (isError(left)) {
    return left!
  }

  // 求值右侧操作数
  const right = evalNode(node.right, env)
  if (isError(right)) {
    return right!
  }

  // 根据操作数类型分派
  if (left!.type() === INTEGER_OBJ && right!.type() === INTEGER_OBJ) {
    return evalIntegerInfixExpression(
      node.operator,
      left as IntegerObject,
      right as IntegerObject
    )
  }

  if (left!.type() === STRING_OBJ && right!.type() === STRING_OBJ) {
    return evalStringInfixExpression(
      node.operator,
      left as StringObject,
      right as StringObject
    )
  }

  // 布尔运算（使用引用比较，因为是单例）
  if (node.operator === '==') {
    return nativeBoolToBooleanObject(left === right)
  }
  if (node.operator === '!=') {
    return nativeBoolToBooleanObject(left !== right)
  }

  // 类型不匹配
  if (left!.type() !== right!.type()) {
    return new ErrorObject(
      `type mismatch: ${left!.type()} ${node.operator} ${right!.type()}`
    )
  }

  return new ErrorObject(
    `unknown operator: ${left!.type()} ${node.operator} ${right!.type()}`
  )
}

/**
 * 求值整数中缀表达式
 */
function evalIntegerInfixExpression(
  operator: string,
  left: IntegerObject,
  right: IntegerObject
): MonkeyObject {
  const leftVal = left.value
  const rightVal = right.value

  switch (operator) {
    case '+':
      return new IntegerObject(leftVal + rightVal)
    case '-':
      return new IntegerObject(leftVal - rightVal)
    case '*':
      return new IntegerObject(leftVal * rightVal)
    case '/':
      return new IntegerObject(Math.floor(leftVal / rightVal))
    case '<':
      return nativeBoolToBooleanObject(leftVal < rightVal)
    case '>':
      return nativeBoolToBooleanObject(leftVal > rightVal)
    case '==':
      return nativeBoolToBooleanObject(leftVal === rightVal)
    case '!=':
      return nativeBoolToBooleanObject(leftVal !== rightVal)
    default:
      return new ErrorObject(
        `unknown operator: ${left.type()} ${operator} ${right.type()}`
      )
  }
}

/**
 * 求值字符串中缀表达式
 */
function evalStringInfixExpression(
  operator: string,
  left: StringObject,
  right: StringObject
): MonkeyObject {
  if (operator !== '+') {
    return new ErrorObject(
      `unknown operator: ${left.type()} ${operator} ${right.type()}`
    )
  }

  // 字符串拼接
  return new StringObject(left.value + right.value)
}
```

#### 求值 if 表达式

```typescript
/**
 * 求值 if 表达式
 */
function evalIfExpression(
  node: IfExpression,
  env: Environment
): MonkeyObject | null {
  // 求值条件
  const condition = evalNode(node.condition, env)
  if (isError(condition)) {
    return condition
  }

  // 判断真值性
  if (isTruthy(condition)) {
    return evalNode(node.consequence, env)
  } else if (node.alternative) {
    return evalNode(node.alternative, env)
  } else {
    return NULL
  }
}

/**
 * 判断对象的真值性
 *
 * 在 Monkey 中：
 * - false 和 null 是 falsy
 * - 其他所有值都是 truthy
 */
function isTruthy(obj: MonkeyObject | null): boolean {
  if (obj === NULL) {
    return false
  }
  if (obj === TRUE) {
    return true
  }
  if (obj === FALSE) {
    return false
  }
  return true
}
```

### 3.4.6 求值函数调用

#### 求值函数字面量

```typescript
/**
 * 求值函数字面量
 *
 * 创建 FunctionObject，保存当前环境（闭包）
 */
function evalFunctionLiteral(
  node: FunctionLiteral,
  env: Environment
): MonkeyObject {
  return new FunctionObject(node.parameters, node.body, env)
}
```

#### 求值函数调用

```typescript
/**
 * 求值函数调用
 */
function evalCallExpression(
  node: CallExpression,
  env: Environment
): MonkeyObject | null {
  // 求值函数表达式
  const func = evalNode(node.func, env)
  if (isError(func)) {
    return func
  }

  // 求值参数列表
  const args = evalExpressions(node.args, env)
  if (args.length === 1 && isError(args[0])) {
    return args[0]
  }

  // 应用函数
  return applyFunction(func!, args)
}

/**
 * 应用函数
 */
function applyFunction(func: MonkeyObject, args: MonkeyObject[]): MonkeyObject {
  // 用户定义的函数
  if (func instanceof FunctionObject) {
    // 创建扩展环境
    const extendedEnv = extendFunctionEnv(func, args)

    // 求值函数体
    const evaluated = evalNode(func.body, extendedEnv)

    // 解包 ReturnValue
    return unwrapReturnValue(evaluated)
  }

  // 内置函数
  if (func instanceof BuiltinObject) {
    return func.fn(...args)
  }

  // 不是函数
  return new ErrorObject(`not a function: ${func.type()}`)
}

/**
 * 扩展函数环境
 *
 * 创建新环境，将参数绑定到参数值
 */
function extendFunctionEnv(
  func: FunctionObject,
  args: MonkeyObject[]
): Environment {
  // 创建新环境，外层环境是函数的闭包环境
  const env = newEnclosedEnvironment(func.env)

  // 绑定参数
  for (let i = 0; i < func.parameters.length; i++) {
    env.set(func.parameters[i].value, args[i])
  }

  return env
}

/**
 * 解包 ReturnValue
 */
function unwrapReturnValue(obj: MonkeyObject | null): MonkeyObject {
  if (obj instanceof ReturnValue) {
    return obj.value
  }
  return obj || NULL
}
```

**完整执行示例：**

```monkey
let add = fn(x, y) { x + y };
add(2, 3);
```

```
1. 求值 let add = fn(x, y) { x + y }
   ├── 创建 FunctionObject
   │   ├── parameters: [x, y]
   │   ├── body: { x + y }
   │   └── env: 全局环境
   └── env.set('add', FunctionObject)

2. 求值 add(2, 3)
   ├── 求值 add → FunctionObject
   ├── 求值参数
   │   ├── 2 → IntegerObject(2)
   │   └── 3 → IntegerObject(3)
   └── applyFunction
       ├── extendFunctionEnv
       │   └── 创建新环境: { x: 2, y: 3, outer: 全局环境 }
       ├── 求值函数体 x + y
       │   ├── 查找 x → IntegerObject(2)
       │   ├── 查找 y → IntegerObject(3)
       │   └── 2 + 3 → IntegerObject(5)
       └── unwrapReturnValue → IntegerObject(5)
```

## 3.5 错误处理

### 错误检测辅助函数

```typescript
/**
 * 检查对象是否为错误
 */
function isError(obj: MonkeyObject | null): boolean {
  if (obj !== null) {
    return obj.type() === ERROR_OBJ
  }
  return false
}
```

### 常见错误类型

```typescript
// 类型错误
new ErrorObject(`type mismatch: INTEGER + STRING`)

// 未知运算符
new ErrorObject(`unknown operator: BOOLEAN - BOOLEAN`)

// 标识符未定义
new ErrorObject(`identifier not found: x`)

// 不可调用
new ErrorObject(`not a function: INTEGER`)

// 索引越界
new ErrorObject(`index out of range: 10`)

// 参数数量错误
new ErrorObject(`wrong number of arguments. got=3, want=1`)
```

## 3.6 内置函数

### 内置函数实现

```typescript
/**
 * len 函数
 *
 * 返回字符串或数组的长度
 */
const lenBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  const arg = args[0]

  if (arg instanceof StringObject) {
    return new IntegerObject(arg.value.length)
  }
  if (arg instanceof ArrayObject) {
    return new IntegerObject(arg.elements.length)
  }

  return new ErrorObject(`argument to 'len' not supported, got ${arg.type()}`)
})

/**
 * first 函数
 *
 * 返回数组的第一个元素
 */
const firstBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'first' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  if (arr.elements.length > 0) {
    return arr.elements[0]
  }

  return NULL
})

/**
 * rest 函数
 *
 * 返回数组除第一个元素外的其余元素
 */
const restBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'rest' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  const length = arr.elements.length

  if (length > 0) {
    const newElements = arr.elements.slice(1)
    return new ArrayObject(newElements)
  }

  return NULL
})

/**
 * push 函数
 *
 * 向数组末尾添加元素，返回新数组
 */
const pushBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 2) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=2`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'push' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  const newElements = [...arr.elements, args[1]]

  return new ArrayObject(newElements)
})

/**
 * puts 函数
 *
 * 打印参数到控制台
 */
const putsBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  for (const arg of args) {
    console.log(arg.inspect())
  }
  return NULL
})

/**
 * 内置函数映射表
 */
export const builtins = new Map<string, BuiltinObject>([
  ['len', lenBuiltin],
  ['first', firstBuiltin],
  ['last', lastBuiltin],
  ['rest', restBuiltin],
  ['push', pushBuiltin],
  ['puts', putsBuiltin],
])
```

## 3.7 完整示例

### 示例 1：斐波那契数列

```monkey
let fibonacci = fn(x) {
  if (x == 0) {
    return 0;
  }
  if (x == 1) {
    return 1;
  }
  return fibonacci(x - 1) + fibonacci(x - 2);
};

fibonacci(10);
// 输出: 55
```

### 示例 2：高阶函数

```monkey
let map = fn(arr, f) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      return accumulated;
    }
    return iter(rest(arr), push(accumulated, f(first(arr))));
  };
  return iter(arr, []);
};

let double = fn(x) { x * 2 };
map([1, 2, 3, 4], double);
// 输出: [2, 4, 6, 8]
```

### 示例 3：闭包

```monkey
let newCounter = fn() {
  let count = 0;
  return fn() {
    count = count + 1;
    return count;
  };
};

let counter = newCounter();
counter();  // 1
counter();  // 2
counter();  // 3
```

## 3.8 测试策略

```typescript
import { describe, it, expect } from 'vitest'
import { Lexer } from '../lexer/lexer'
import { Parser } from '../parser/parser'
import { evalNode } from './evaluator'
import { Environment } from '../object/environment'
import * as obj from '../object/object'

describe('Evaluator', () => {
  it('应该正确求值整数表达式', () => {
    const tests = [
      { input: '5', expected: 5 },
      { input: '10', expected: 10 },
      { input: '-5', expected: -5 },
      { input: '5 + 5 + 5 + 5 - 10', expected: 10 },
      { input: '2 * 2 * 2 * 2 * 2', expected: 32 },
      { input: '-50 + 100 + -50', expected: 0 },
      { input: '5 * 2 + 10', expected: 20 },
      { input: '5 + 2 * 10', expected: 25 },
      { input: '20 + 2 * -10', expected: 0 },
      { input: '50 / 2 * 2 + 10', expected: 60 },
      { input: '2 * (5 + 10)', expected: 30 },
      { input: '3 * 3 * 3 + 10', expected: 37 },
      { input: '3 * (3 * 3) + 10', expected: 37 },
      { input: '(5 + 10 * 2 + 15 / 3) * 2 + -10', expected: 50 },
    ]

    for (const tt of tests) {
      const evaluated = testEval(tt.input)
      testIntegerObject(evaluated, tt.expected)
    }
  })

  it('应该正确求值布尔表达式', () => {
    const tests = [
      { input: 'true', expected: true },
      { input: 'false', expected: false },
      { input: '1 < 2', expected: true },
      { input: '1 > 2', expected: false },
      { input: '1 < 1', expected: false },
      { input: '1 > 1', expected: false },
      { input: '1 == 1', expected: true },
      { input: '1 != 1', expected: false },
      { input: '1 == 2', expected: false },
      { input: '1 != 2', expected: true },
    ]

    for (const tt of tests) {
      const evaluated = testEval(tt.input)
      testBooleanObject(evaluated, tt.expected)
    }
  })

  it('应该正确处理 if 表达式', () => {
    const tests = [
      { input: 'if (true) { 10 }', expected: 10 },
      { input: 'if (false) { 10 }', expected: null },
      { input: 'if (1) { 10 }', expected: 10 },
      { input: 'if (1 < 2) { 10 }', expected: 10 },
      { input: 'if (1 > 2) { 10 }', expected: null },
      { input: 'if (1 > 2) { 10 } else { 20 }', expected: 20 },
      { input: 'if (1 < 2) { 10 } else { 20 }', expected: 10 },
    ]

    for (const tt of tests) {
      const evaluated = testEval(tt.input)
      if (typeof tt.expected === 'number') {
        testIntegerObject(evaluated, tt.expected)
      } else {
        testNullObject(evaluated)
      }
    }
  })

  it('应该正确处理函数调用', () => {
    const tests = [
      { input: 'let identity = fn(x) { x; }; identity(5);', expected: 5 },
      {
        input: 'let identity = fn(x) { return x; }; identity(5);',
        expected: 5,
      },
      { input: 'let double = fn(x) { x * 2; }; double(5);', expected: 10 },
      { input: 'let add = fn(x, y) { x + y; }; add(5, 5);', expected: 10 },
      {
        input: 'let add = fn(x, y) { x + y; }; add(5 + 5, add(5, 5));',
        expected: 20,
      },
      { input: 'fn(x) { x; }(5)', expected: 5 },
    ]

    for (const tt of tests) {
      const evaluated = testEval(tt.input)
      testIntegerObject(evaluated, tt.expected)
    }
  })

  it('应该正确处理闭包', () => {
    const input = `
      let newAdder = fn(x) {
        fn(y) { x + y };
      };
      
      let addTwo = newAdder(2);
      addTwo(2);
    `

    const evaluated = testEval(input)
    testIntegerObject(evaluated, 4)
  })
})

// 辅助函数
function testEval(input: string): obj.MonkeyObject | null {
  const lexer = new Lexer(input)
  const parser = new Parser(lexer)
  const program = parser.parseProgram()
  const env = new Environment()

  return evalNode(program, env)
}

function testIntegerObject(
  obj: obj.MonkeyObject | null,
  expected: number
): void {
  expect(obj).toBeInstanceOf(obj.IntegerObject)
  const result = obj as obj.IntegerObject
  expect(result.value).toBe(expected)
}

function testBooleanObject(
  obj: obj.MonkeyObject | null,
  expected: boolean
): void {
  expect(obj).toBeInstanceOf(obj.BooleanObject)
  const result = obj as obj.BooleanObject
  expect(result.value).toBe(expected)
}

function testNullObject(obj: obj.MonkeyObject | null): void {
  expect(obj).toBe(obj.NULL)
}
```

## 3.9 性能优化

### 1. 对象池

对于频繁创建的小对象（如 TRUE、FALSE、NULL），使用单例模式：

```typescript
// ✅ 单例，避免重复创建
export const TRUE = new BooleanObject(true)
export const FALSE = new BooleanObject(false)
export const NULL = new NullObject()

// ❌ 每次都创建新对象
return new BooleanObject(true)
```

### 2. 短路求值

在布尔运算中，尽早返回：

```typescript
// 如果条件为真，不需要求值 alternative
if (isTruthy(condition)) {
  return evalNode(node.consequence, env)
}
```

### 3. 尾调用优化（可选）

虽然 JavaScript 不支持尾调用优化，但可以手动实现：

```monkey
// 尾递归
let factorial = fn(n, acc) {
  if (n == 0) {
    return acc;
  }
  return factorial(n - 1, n * acc);
};
```

## 小结

在本章中，我们实现了完整的求值器：

### 核心概念

- **求值**：将 AST 转换为运行时对象
- **对象系统**：统一表示运行时值
- **环境**：管理变量绑定和作用域
- **闭包**：函数和其词法环境的组合

### 实现技术

- **递归求值**：遍历 AST，递归计算每个节点
- **环境链**：实现嵌套作用域和变量查找
- **特殊对象**：ReturnValue 和 ErrorObject 控制执行流
- **内置函数**：用宿主语言实现核心功能

### 设计原则

- **单一职责**：每个求值函数只处理一种节点类型
- **错误优先**：立即检查并传播错误
- **不可变性**：对象创建后不修改（如 push 返回新数组）
- **明确语义**：清晰定义真值性、运算符行为等

下一章我们将学习如何扩展这个解释器，添加更多特性。

---

**上一章**：[第二章：语法分析](./02-语法分析.md)

**下一章**：[第四章：扩展解释器](./04-扩展解释器.md)

**源代码参考**：

- [evaluator.ts](../src/monkey/evaluator/evaluator.ts) - 求值器实现
- [object.ts](../src/monkey/object/object.ts) - 对象系统
- [environment.ts](../src/monkey/object/environment.ts) - 环境实现
- [builtins.ts](../src/monkey/evaluator/builtins.ts) - 内置函数
- [evaluator.test.ts](../src/monkey/evaluator/evaluator.test.ts) - 测试用例
