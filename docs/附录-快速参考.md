# 附录：快速参考

## 目录

- [A. Monkey 语言语法](#a-monkey-语言语法)
- [B. 内置函数参考](#b-内置函数参考)
- [C. 对象类型参考](#c-对象类型参考)
- [D. 错误信息参考](#d-错误信息参考)
- [E. 常见问题](#e-常见问题)
- [F. 性能优化技巧](#f-性能优化技巧)
- [G. 测试指南](#g-测试指南)

## A. Monkey 语言语法

### A.1 词法元素

#### 关键字

```
fn      let      true     false
if      else     return
```

#### 运算符

```
+       -        *        /
==      !=       <        >
!       =
```

#### 分隔符

```
,       ;        :
(       )        {        }
[       ]
```

### A.2 运算符优先级

从低到高：

1. `LOWEST`
2. `EQUALS` - `==`, `!=`
3. `LESSGREATER` - `<`, `>`
4. `SUM` - `+`, `-`
5. `PRODUCT` - `*`, `/`
6. `PREFIX` - `-X`, `!X`
7. `CALL` - `function(X)`
8. `INDEX` - `array[index]`

### A.3 语法示例

```monkey
// 变量声明
let x = 5;
let name = "Monkey";

// 函数定义
let add = fn(a, b) {
  return a + b;
};

// 条件表达式
let max = fn(a, b) {
  if (a > b) {
    a
  } else {
    b
  }
};

// 数组
let arr = [1, 2, 3, 4, 5];

// 哈希表
let person = {
  "name": "John",
  "age": 30
};

// 高阶函数
let twice = fn(f, x) {
  return f(f(x));
};

// 闭包
let newAdder = fn(x) {
  fn(y) { x + y };
};
```

## B. 内置函数参考

### B.1 `len(obj)`

获取对象的长度。

**参数**：字符串或数组

**返回值**：整数

**示例**：

```monkey
len("hello");      // 5
len([1, 2, 3]);    // 3
```

### B.2 `first(array)`

获取数组的第一个元素。

**示例**：

```monkey
first([1, 2, 3]);  // 1
first([]);         // null
```

### B.3 `last(array)`

获取数组的最后一个元素。

**示例**：

```monkey
last([1, 2, 3]);   // 3
```

### B.4 `rest(array)`

获取数组除第一个元素外的所有元素。

**示例**：

```monkey
rest([1, 2, 3, 4]); // [2, 3, 4]
```

### B.5 `push(array, element)`

向数组添加一个元素，返回新数组（不修改原数组）。

**示例**：

```monkey
push([1, 2], 3);    // [1, 2, 3]
```

### B.6 `puts(...args)`

打印输出到标准输出。

**示例**：

```monkey
puts("Hello, World!");
puts(1, 2, 3);
```

## C. 对象类型参考

### C.1 对象类型常量

| 常量               | 类型             | 说明       |
| ------------------ | ---------------- | ---------- |
| `INTEGER_OBJ`      | `"INTEGER"`      | 整数       |
| `BOOLEAN_OBJ`      | `"BOOLEAN"`      | 布尔值     |
| `STRING_OBJ`       | `"STRING"`       | 字符串     |
| `NULL_OBJ`         | `"NULL"`         | 空值       |
| `RETURN_VALUE_OBJ` | `"RETURN_VALUE"` | 返回值包装 |
| `ERROR_OBJ`        | `"ERROR"`        | 错误       |
| `FUNCTION_OBJ`     | `"FUNCTION"`     | 函数       |
| `BUILTIN_OBJ`      | `"BUILTIN"`      | 内置函数   |
| `ARRAY_OBJ`        | `"ARRAY"`        | 数组       |
| `HASH_OBJ`         | `"HASH"`         | 哈希表     |

### C.2 可哈希的类型

以下类型可以作为哈希表的键：

- `IntegerObject`
- `BooleanObject`
- `StringObject`

### C.3 Truthiness 规则

在条件表达式中，以下值被视为假：

- `false`
- `null`

所有其他值（包括 `0`、空字符串 `""`、空数组 `[]`）都被视为真。

**示例**：

```monkey
if (0) { puts("true"); }     // 输出 "true"
if ("") { puts("true"); }    // 输出 "true"
if (false) { puts("true"); } // 不输出
if (null) { puts("true"); }  // 不输出
```

## D. 错误信息参考

### D.1 词法错误

| 错误信息        | 说明               |
| --------------- | ------------------ |
| `ILLEGAL` token | 遇到无法识别的字符 |

### D.2 语法错误

| 错误信息模式                                 | 说明                 |
| -------------------------------------------- | -------------------- |
| `expected next token to be X, got Y instead` | Token 类型不匹配     |
| `no prefix parse function for X found`       | 没有找到前缀解析函数 |
| `could not parse X as integer`               | 整数解析失败         |

### D.3 运行时错误

| 错误信息模式                | 说明               |
| --------------------------- | ------------------ |
| `unknown operator: X`       | 未知的运算符       |
| `type mismatch: X Y Z`      | 类型不匹配         |
| `identifier not found: X`   | 标识符未定义       |
| `not a function: X`         | 尝试调用非函数对象 |
| `wrong number of arguments` | 函数参数个数错误   |
| `unusable as hash key: X`   | 类型不可作为哈希键 |

## E. 常见问题

### E.1 为什么分号是可选的？

Monkey 语言的设计使得分号在大多数情况下是可选的，这提供了更灵活的编码风格。

### E.2 数组和哈希表是可变的吗？

内置函数（如 `push`、`rest`）遵循函数式编程的不可变性原则，不会修改原数组，而是返回新数组。

### E.3 如何实现循环？

Monkey 没有内置的循环语法，但可以使用递归：

```monkey
let loop = fn(n) {
  if (n > 0) {
    puts(n);
    loop(n - 1);
  }
};

loop(5);  // 输出 5, 4, 3, 2, 1
```

### E.4 支持嵌套函数吗？

支持！函数可以定义在函数内部，并形成闭包。

### E.5 如何处理错误？

Monkey 在遇到运行时错误时会返回 `ErrorObject`，并停止执行。目前没有内置的异常处理机制。

### E.6 支持浮点数吗？

当前版本只支持整数。除法运算会向下取整。

### E.7 变量作用域如何工作？

Monkey 使用词法作用域（静态作用域）。变量的作用域在定义时确定，内层作用域可以访问外层作用域的变量。

## F. 性能优化技巧

### F.1 避免重复计算

使用变量缓存计算结果：

```monkey
// 不好
let result = expensiveComputation() + expensiveComputation();

// 好
let cached = expensiveComputation();
let result = cached + cached;
```

### F.2 尾递归优化

虽然当前实现不支持尾调用优化，但编写尾递归风格的代码是个好习惯：

```monkey
// 尾递归（使用累加器）
let sumTail = fn(n, acc) {
  if (n == 0) {
    acc
  } else {
    sumTail(n - 1, acc + n)
  }
};
```

### F.3 使用内置函数

内置函数用 TypeScript 实现，比用 Monkey 实现的等价函数更快。

## G. 测试指南

### G.1 运行测试

```bash
# 运行所有测试
pnpm test

# 运行特定模块的测试
pnpm test lexer
pnpm test parser
pnpm test evaluator

# 查看测试覆盖率
pnpm test -- --coverage
```

### G.2 编写测试

使用 Vitest 测试框架：

```typescript
import { describe, it, expect } from 'vitest'
import { Lexer } from './lexer'

describe('Lexer', () => {
  it('should tokenize simple expression', () => {
    const input = '5 + 5'
    const lexer = new Lexer(input)

    const tok = lexer.nextToken()
    expect(tok.Type).toBe('INT')
    expect(tok.Literal).toBe('5')
  })
})
```

## 相关资源

### 推荐阅读

- 《Writing An Interpreter In Go》 - Thorsten Ball
- 《Crafting Interpreters》 - Robert Nystrom
- 《Structure and Interpretation of Computer Programs》

### 在线资源

- [TypeScript 官方文档](https://www.typescriptlang.org/docs/)
- [Vitest 文档](https://vitest.dev/)

---

**返回目录**：[README](./README.md)
