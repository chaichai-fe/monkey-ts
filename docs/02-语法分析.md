# 第二章：语法分析

> "语法分析器的任务是发现源程序的结构。" —— 编译原理

## 目录

- [2.1 语法分析简介](#21-语法分析简介)
  - [2.1.1 什么是语法分析](#211-什么是语法分析)
  - [2.1.2 从词法单元到抽象语法树](#212-从词法单元到抽象语法树)
  - [2.1.3 语法分析器的职责](#213-语法分析器的职责)
- [2.2 抽象语法树（AST）](#22-抽象语法树ast)
  - [2.2.1 AST 的概念](#221-ast-的概念)
  - [2.2.2 为什么需要 AST](#222-为什么需要-ast)
  - [2.2.3 AST 的设计原则](#223-ast-的设计原则)
  - [2.2.4 节点层次结构](#224-节点层次结构)
  - [2.2.5 语句节点详解](#225-语句节点详解)
  - [2.2.6 表达式节点详解](#226-表达式节点详解)
- [2.3 解析策略：普拉特解析法](#23-解析策略普拉特解析法)
  - [2.3.1 为什么选择普拉特解析法](#231-为什么选择普拉特解析法)
  - [2.3.2 运算符优先级](#232-运算符优先级)
  - [2.3.3 前缀解析函数](#233-前缀解析函数)
  - [2.3.4 中缀解析函数](#234-中缀解析函数)
  - [2.3.5 普拉特解析法的核心算法](#235-普拉特解析法的核心算法)
- [2.4 实现语法分析器](#24-实现语法分析器)
  - [2.4.1 Parser 类的整体架构](#241-parser-类的整体架构)
  - [2.4.2 状态管理和错误处理](#242-状态管理和错误处理)
  - [2.4.3 解析函数注册机制](#243-解析函数注册机制)
- [2.5 解析语句](#25-解析语句)
  - [2.5.1 解析 let 语句](#251-解析-let-语句)
  - [2.5.2 解析 return 语句](#252-解析-return-语句)
  - [2.5.3 解析表达式语句](#253-解析表达式语句)
  - [2.5.4 解析代码块](#254-解析代码块)
- [2.6 解析表达式](#26-解析表达式)
  - [2.6.1 解析字面量](#261-解析字面量)
  - [2.6.2 解析前缀表达式](#262-解析前缀表达式)
  - [2.6.3 解析中缀表达式](#263-解析中缀表达式)
  - [2.6.4 解析 if 表达式](#264-解析-if-表达式)
  - [2.6.5 解析函数字面量](#265-解析函数字面量)
  - [2.6.6 解析函数调用](#266-解析函数调用)
- [2.7 完整示例和调试](#27-完整示例和调试)
- [2.8 测试策略](#28-测试策略)
- [2.9 常见问题和陷阱](#29-常见问题和陷阱)

---

## 2.1 语法分析简介

### 2.1.1 什么是语法分析

语法分析（Parsing）是编译器的第二个阶段，紧跟在词法分析之后。它的核心任务是理解 Token 序列的**结构关系**，并将其转换为一个树形的数据结构——**抽象语法树（Abstract Syntax Tree, AST）**。

#### 类比理解

想象你在分析一个英文句子：

```
"The quick brown fox jumps over the lazy dog."
```

**词法分析阶段**已经将其分解为单词：

```
["The", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog", "."]
```

**语法分析阶段**要理解这些单词之间的关系：

```
句子
├── 主语: "The quick brown fox"
│   ├── 冠词: "The"
│   ├── 形容词: "quick"
│   ├── 形容词: "brown"
│   └── 名词: "fox"
├── 谓语: "jumps over"
│   ├── 动词: "jumps"
│   └── 介词: "over"
└── 宾语: "the lazy dog"
    ├── 冠词: "the"
    ├── 形容词: "lazy"
    └── 名词: "dog"
```

在编程语言中，语法分析做的是类似的工作。

### 2.1.2 从词法单元到抽象语法树

让我们看一个具体的转换过程。

#### 输入（词法单元流）

```typescript
const input = 'let x = 5 + 5;'
```

**词法分析后：**

```
[LET] [IDENT:x] [=] [INT:5] [+] [INT:5] [;]
```

#### 输出（抽象语法树）

```
Program
└── LetStatement
    ├── name: Identifier("x")
    └── value: InfixExpression
        ├── left: IntegerLiteral(5)
        ├── operator: "+"
        └── right: IntegerLiteral(5)
```

**可视化表示：**

```
         Program
            |
      LetStatement
       /    |    \
  Token  Name  Value
   (let)  (x)    |
              InfixExpr(+)
              /         \
        IntLit(5)    IntLit(5)
```

### 2.1.3 语法分析器的职责

语法分析器（Parser）有以下几个核心职责：

#### 1. **验证语法正确性**

检查 Token 序列是否符合语言的语法规则。

```monkey
// ✅ 正确
let x = 5;

// ❌ 错误：缺少等号
let x 5;

// ❌ 错误：表达式不完整
let x = ;
```

Parser 会在发现语法错误时报告错误信息：

```
expected next token to be '=', got 'INT' instead
```

#### 2. **构建语法树**

将平面的 Token 序列转换为层次化的树结构。

```
Token 序列（一维）:
[let, x, =, 5, +, 5]

AST（多维树结构）:
    let
    / \
   x   +
      / \
     5   5
```

#### 3. **保留语义信息**

AST 不仅包含语法结构，还保留了重要的语义信息。

```typescript
// 源代码
let x = 5;

// AST 节点
LetStatement {
  token: { Type: 'LET', Literal: 'let' },
  name: Identifier { value: 'x' },
  value: IntegerLiteral { value: 5 }
}
```

#### 4. **处理运算符优先级**

正确理解表达式中运算符的优先级和结合性。

```monkey
1 + 2 * 3
```

**错误的理解：**

```
    +
   / \
  1   *
     / \
    2   3
// 这会计算成 (1 + 2) * 3 = 9
```

**正确的理解：**

```
    +
   / \
  1   *
     / \
    2   3
// 这会计算成 1 + (2 * 3) = 7
```

## 2.2 抽象语法树（AST）

### 2.2.1 AST 的概念

抽象语法树（Abstract Syntax Tree）是源代码的树形表示，它：

- **抽象**：省略了源代码中的某些细节（如括号、分号）
- **语法**：反映了代码的语法结构
- **树**：使用树形数据结构组织

#### 为什么叫"抽象"？

考虑以下代码：

```monkey
(1 + 2) * 3
```

在 AST 中，括号会被省略，因为树的结构已经表达了运算顺序：

```
    *
   / \
  +   3
 / \
1   2
```

括号只是为了人类阅读，AST 不需要它们。

### 2.2.2 为什么需要 AST

#### 1. **结构化表示**

Token 流是平面的，而代码具有层次结构。AST 清晰地表达了这种层次关系。

**示例：嵌套的 if 语句**

```monkey
if (x > 5) {
  if (y > 10) {
    return true;
  }
}
```

**Token 流**（难以看出嵌套关系）：

```
[IF, LPAREN, IDENT, GT, INT, RPAREN, LBRACE, IF, ...]
```

**AST**（嵌套关系清晰）：

```
IfExpression
├── condition: (x > 5)
└── consequence:
    └── IfExpression
        ├── condition: (y > 10)
        └── consequence:
            └── ReturnStatement(true)
```

#### 2. **便于遍历和处理**

树形结构天然适合递归处理。

```typescript
// 求值器可以递归遍历 AST
function evalNode(node: Node): Object {
  if (node instanceof IntegerLiteral) {
    return new Integer(node.value)
  }
  if (node instanceof InfixExpression) {
    const left = evalNode(node.left)
    const right = evalNode(node.right)
    return applyOperator(node.operator, left, right)
  }
  // ...
}
```

#### 3. **类型安全**

使用 TypeScript 的类型系统确保 AST 的正确性。

```typescript
// ✅ 类型安全：编译时检查
function visitLetStatement(stmt: LetStatement) {
  console.log(stmt.name.value) // OK: name 肯定存在
}

// ❌ 如果使用普通对象，可能出现运行时错误
function visitStatement(stmt: any) {
  console.log(stmt.name.value) // 可能报错：name 不存在
}
```

#### 4. **支持代码转换和优化**

AST 可以被修改、优化或转换为其他形式。

```typescript
// 常量折叠优化
// 将 5 + 3 优化为 8

// 优化前的 AST
InfixExpression(+)
├── IntegerLiteral(5)
└── IntegerLiteral(3)

// 优化后的 AST
IntegerLiteral(8)
```

### 2.2.3 AST 的设计原则

#### 1. **节点类型明确**

每种语法结构都有对应的节点类型。

```typescript
// ✅ 好：类型明确
class LetStatement {
  name: Identifier
  value: Expression
}

// ❌ 不好：类型模糊
class Statement {
  type: string
  data: any
}
```

#### 2. **保留必要信息**

AST 应该保留求值或代码生成所需的所有信息。

```typescript
class FunctionLiteral {
  token: Token // 保留位置信息（用于错误报告）
  parameters: Identifier[] // 参数列表
  body: BlockStatement // 函数体
}
```

#### 3. **接口统一**

所有节点实现相同的基础接口，便于统一处理。

```typescript
interface Node {
  tokenLiteral(): string // 返回 Token 字面量
  toString(): string // 返回字符串表示
}
```

### 2.2.4 节点层次结构

Monkey 的 AST 有以下层次结构：

```
Node (基础接口)
├── Statement (语句接口)
│   ├── LetStatement         - let 变量声明
│   ├── ReturnStatement      - return 返回语句
│   ├── ExpressionStatement  - 表达式语句
│   └── BlockStatement       - 代码块 { }
│
└── Expression (表达式接口)
    ├── Identifier           - 标识符 x, y
    ├── IntegerLiteral       - 整数 42
    ├── StringLiteral        - 字符串 "hello"
    ├── BooleanLiteral       - 布尔值 true/false
    ├── ArrayLiteral         - 数组 [1, 2, 3]
    ├── HashLiteral          - 哈希表 {"key": "value"}
    ├── PrefixExpression     - 前缀表达式 -5, !true
    ├── InfixExpression      - 中缀表达式 5 + 3
    ├── IfExpression         - if 表达式
    ├── FunctionLiteral      - 函数字面量 fn(x) { x }
    ├── CallExpression       - 函数调用 add(1, 2)
    └── IndexExpression      - 索引访问 arr[0]
```

#### 基础接口

```typescript
/**
 * Node 接口
 *
 * 所有 AST 节点的基础接口
 */
export interface Node {
  /**
   * 返回节点关联的 Token 字面量
   * 主要用于调试和错误报告
   */
  tokenLiteral(): string

  /**
   * 返回节点的字符串表示
   * 可以重新生成源代码
   */
  toString(): string
}
```

#### Statement 和 Expression 的区分

这是 AST 设计中的重要概念：

**Statement（语句）**：执行某些操作，但不产生值

```monkey
let x = 5;      // 声明语句
return x;       // 返回语句
```

**Expression（表达式）**：产生一个值

```monkey
5 + 3           // 产生值 8
fn(x) { x * 2 } // 产生一个函数对象
x > 5           // 产生布尔值
```

**在 Monkey 中，表达式也可以作为语句：**

```monkey
5 + 3;  // 表达式语句：计算结果被丢弃
```

```typescript
/**
 * Statement 接口
 */
export interface Statement extends Node {
  statementNode(): void // 标记方法，用于类型区分
}

/**
 * Expression 接口
 */
export interface Expression extends Node {
  expressionNode(): void // 标记方法，用于类型区分
}
```

### 2.2.5 语句节点详解

#### Program（程序根节点）

```typescript
/**
 * Program 类
 *
 * AST 的根节点，表示整个程序
 * 一个程序由零个或多个语句组成
 */
export class Program implements Node {
  statements: Statement[] = []

  tokenLiteral(): string {
    if (this.statements.length > 0) {
      return this.statements[0].tokenLiteral()
    }
    return ''
  }

  toString(): string {
    let out = ''
    for (const stmt of this.statements) {
      out += stmt.toString()
    }
    return out
  }
}
```

**示例：**

```monkey
// 源代码
let x = 5;
let y = 10;

// AST
Program {
  statements: [
    LetStatement { name: "x", value: 5 },
    LetStatement { name: "y", value: 10 }
  ]
}
```

#### LetStatement（变量声明）

```typescript
/**
 * LetStatement 类
 *
 * 表示变量声明语句
 * 语法：let <identifier> = <expression>;
 */
export class LetStatement implements Statement {
  token: Token // LET token
  name: Identifier // 变量名
  value: Expression // 变量值

  constructor(token: Token, name: Identifier, value: Expression) {
    this.token = token
    this.name = name
    this.value = value
  }

  statementNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return `${this.tokenLiteral()} ${this.name.toString()} = ${this.value.toString()};`
  }
}
```

**执行流程示例：**

```
源代码: "let x = 5 + 3;"

解析过程:
1. 识别 LET token
2. 期望并读取 IDENT token (x)
3. 期望并读取 ASSIGN token (=)
4. 解析表达式 (5 + 3)
5. 构造 LetStatement 节点

生成的 AST:
LetStatement {
  token: { Type: 'LET', Literal: 'let' },
  name: Identifier { value: 'x' },
  value: InfixExpression {
    left: IntegerLiteral { value: 5 },
    operator: '+',
    right: IntegerLiteral { value: 3 }
  }
}
```

#### ReturnStatement（返回语句）

```typescript
/**
 * ReturnStatement 类
 *
 * 表示返回语句
 * 语法：return <expression>;
 */
export class ReturnStatement implements Statement {
  token: Token // RETURN token
  returnValue: Expression // 返回值表达式

  constructor(token: Token, returnValue: Expression) {
    this.token = token
    this.returnValue = returnValue
  }

  statementNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return `${this.tokenLiteral()} ${this.returnValue.toString()};`
  }
}
```

#### BlockStatement（代码块）

```typescript
/**
 * BlockStatement 类
 *
 * 表示代码块，由多个语句组成
 * 语法：{ <statement>* }
 */
export class BlockStatement implements Statement {
  token: Token // { token
  statements: Statement[] = [] // 代码块中的语句列表

  constructor(token: Token) {
    this.token = token
  }

  statementNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    let out = ''
    for (const stmt of this.statements) {
      out += stmt.toString()
    }
    return out
  }
}
```

**用途：**

```monkey
// 函数体是代码块
fn(x) {
  let y = x * 2;
  return y;
}

// if 的 consequence 是代码块
if (x > 5) {
  puts("x is greater than 5");
  return x;
}
```

### 2.2.6 表达式节点详解

#### IntegerLiteral（整数字面量）

```typescript
/**
 * IntegerLiteral 类
 *
 * 表示整数字面量
 */
export class IntegerLiteral implements Expression {
  token: Token // INT token
  value: number // 整数值

  constructor(token: Token, value: number) {
    this.token = token
    this.value = value
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return this.token.Literal
  }
}
```

#### PrefixExpression（前缀表达式）

```typescript
/**
 * PrefixExpression 类
 *
 * 表示前缀表达式（一元运算）
 * 语法：<operator><expression>
 * 例如：-5, !true
 */
export class PrefixExpression implements Expression {
  token: Token // 前缀运算符 token
  operator: string // 运算符字符串
  right: Expression // 右侧表达式

  constructor(token: Token, operator: string, right: Expression) {
    this.token = token
    this.operator = operator
    this.right = right
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return `(${this.operator}${this.right.toString()})`
  }
}
```

**示例：**

```monkey
-5
!true
```

**AST 表示：**

```typescript
// -5
PrefixExpression {
  operator: '-',
  right: IntegerLiteral { value: 5 }
}

// !true
PrefixExpression {
  operator: '!',
  right: BooleanLiteral { value: true }
}
```

#### InfixExpression（中缀表达式）

```typescript
/**
 * InfixExpression 类
 *
 * 表示中缀表达式（二元运算）
 * 语法：<expression> <operator> <expression>
 * 例如：5 + 3, x * y, a == b
 */
export class InfixExpression implements Expression {
  token: Token // 运算符 token
  left: Expression // 左侧表达式
  operator: string // 运算符字符串
  right: Expression // 右侧表达式

  constructor(
    token: Token,
    left: Expression,
    operator: string,
    right: Expression
  ) {
    this.token = token
    this.left = left
    this.operator = operator
    this.right = right
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return `(${this.left.toString()} ${this.operator} ${this.right.toString()})`
  }
}
```

**运算符优先级的体现：**

```monkey
1 + 2 * 3
```

**正确的 AST：**

```
InfixExpression(+)
├── left: IntegerLiteral(1)
└── right: InfixExpression(*)
    ├── left: IntegerLiteral(2)
    └── right: IntegerLiteral(3)
```

## 2.3 解析策略：普拉特解析法

### 2.3.1 为什么选择普拉特解析法

在讲解普拉特解析法（Pratt Parsing）之前，让我们先了解为什么需要它。

#### 表达式解析的挑战

考虑以下表达式：

```monkey
1 + 2 * 3 - 4 / 2
```

Parser 需要回答以下问题：

1. **运算符优先级**：`*` 和 `/` 应该先于 `+` 和 `-` 执行
2. **结合性**：连续的同优先级运算符如何结合
3. **括号处理**：`(1 + 2) * 3` 中括号改变了优先级
4. **前缀运算符**：`-5` 中的 `-` 是前缀运算符
5. **函数调用**：`add(1, 2)` 中的 `(` 是中缀运算符

#### 传统方法的问题

**递归下降解析**需要为每个优先级编写单独的函数：

```typescript
// ❌ 繁琐：每个优先级都要一个函数
parseExpression()
  ├── parseTerm()
  │   ├── parseFactor()
  │   │   └── parsePrimary()
  │   └── ...
  └── ...
```

**普拉特解析法的优势：**

```typescript
// ✅ 简洁：一个核心函数 + 注册表
parseExpression(precedence)
  ├── prefixParseFns[token]
  └── infixParseFns[token]
```

### 2.3.2 运算符优先级

优先级是一个数字，数字越大优先级越高。

#### 优先级定义

```typescript
/**
 * 运算符优先级枚举
 *
 * 数值越大，优先级越高
 * 用于 Pratt 解析法中判断解析顺序
 */
const enum Precedence {
  LOWEST = 1, // 最低优先级
  EQUALS, // == 或 !=
  LESSGREATER, // < 或 >
  SUM, // + 或 -
  PRODUCT, // * 或 /
  PREFIX, // -X 或 !X
  CALL, // myFunction(X)
  INDEX, // array[index]
}
```

**为什么使用枚举？**

TypeScript 的枚举会自动递增值：

```typescript
Precedence.LOWEST = 1
Precedence.EQUALS = 2
Precedence.LESSGREATER = 3
Precedence.SUM = 4
Precedence.PRODUCT = 5
Precedence.PREFIX = 6
Precedence.CALL = 7
Precedence.INDEX = 8
```

#### Token 到优先级的映射

```typescript
/**
 * Token 类型到优先级的映射表
 *
 * 用于快速查找运算符的优先级
 */
const precedences: Record<TokenType, Precedence> = {
  [EQ]: Precedence.EQUALS, // ==
  [NOT_EQ]: Precedence.EQUALS, // !=
  [LT]: Precedence.LESSGREATER, // <
  [GT]: Precedence.LESSGREATER, // >
  [PLUS]: Precedence.SUM, // +
  [MINUS]: Precedence.SUM, // -
  [SLASH]: Precedence.PRODUCT, // /
  [ASTERISK]: Precedence.PRODUCT, // *
  [LPAREN]: Precedence.CALL, // (
  [LBRACKET]: Precedence.INDEX, // [
}
```

#### 优先级比较示例

```monkey
1 + 2 * 3
```

**解析过程：**

```
1. 解析 1 (字面量)
2. 遇到 +，优先级 = SUM (4)
3. 开始解析右侧，当前优先级 = SUM (4)
4. 解析 2 (字面量)
5. 遇到 *，优先级 = PRODUCT (5)
6. 因为 PRODUCT (5) > SUM (4)，继续解析
7. 解析 3 (字面量)
8. 返回 (2 * 3)
9. 返回 1 + (2 * 3)
```

### 2.3.3 前缀解析函数

前缀解析函数处理出现在表达式开始位置的 Token。

#### 定义

```typescript
/**
 * 前缀解析函数类型
 *
 * 用于解析出现在表达式前缀位置的 Token
 * 不接收任何参数，返回解析出的表达式
 */
type PrefixParseFn = () => Expression | null
```

#### 前缀 Token 示例

```monkey
-5          // - 是前缀运算符
!true       // ! 是前缀运算符
5           // 5 本身是前缀表达式（字面量）
x           // x 是前缀表达式（标识符）
(1 + 2)     // ( 开始一个分组表达式
fn(x) { x } // fn 开始一个函数字面量
[1, 2, 3]   // [ 开始一个数组字面量
```

#### 注册前缀解析函数

```typescript
// 在 Parser 构造函数中注册
constructor(lexer: Lexer) {
  // ... 初始化 ...

  // 注册前缀解析函数
  this.registerPrefix(IDENT, this.parseIdentifier.bind(this))
  this.registerPrefix(INT, this.parseIntegerLiteral.bind(this))
  this.registerPrefix(STRING, this.parseStringLiteral.bind(this))
  this.registerPrefix(BANG, this.parsePrefixExpression.bind(this))
  this.registerPrefix(MINUS, this.parsePrefixExpression.bind(this))
  this.registerPrefix(TRUE, this.parseBoolean.bind(this))
  this.registerPrefix(FALSE, this.parseBoolean.bind(this))
  this.registerPrefix(LPAREN, this.parseGroupedExpression.bind(this))
  this.registerPrefix(IF, this.parseIfExpression.bind(this))
  this.registerPrefix(FUNCTION, this.parseFunctionLiteral.bind(this))
  this.registerPrefix(LBRACKET, this.parseArrayLiteral.bind(this))
  this.registerPrefix(LBRACE, this.parseHashLiteral.bind(this))
}
```

### 2.3.4 中缀解析函数

中缀解析函数处理出现在两个表达式之间的 Token。

#### 定义

```typescript
/**
 * 中缀解析函数类型
 *
 * 用于解析出现在表达式中缀位置的 Token
 * 接收左侧表达式作为参数，返回包含左侧的新表达式
 */
type InfixParseFn = (left: Expression) => Expression | null
```

**为什么需要 left 参数？**

中缀运算符需要知道左侧的表达式：

```monkey
5 + 3
^   ^
|   └── 中缀运算符 +
└────── 左侧表达式 5
```

#### 中缀 Token 示例

```monkey
5 + 3           // + 是中缀运算符
x * y           // * 是中缀运算符
a == b          // == 是中缀运算符
add(1, 2)       // ( 是中缀运算符（函数调用）
arr[0]          // [ 是中缀运算符（索引访问）
```

#### 注册中缀解析函数

```typescript
// 注册中缀解析函数
this.registerInfix(PLUS, this.parseInfixExpression.bind(this))
this.registerInfix(MINUS, this.parseInfixExpression.bind(this))
this.registerInfix(SLASH, this.parseInfixExpression.bind(this))
this.registerInfix(ASTERISK, this.parseInfixExpression.bind(this))
this.registerInfix(EQ, this.parseInfixExpression.bind(this))
this.registerInfix(NOT_EQ, this.parseInfixExpression.bind(this))
this.registerInfix(LT, this.parseInfixExpression.bind(this))
this.registerInfix(GT, this.parseInfixExpression.bind(this))
this.registerInfix(LPAREN, this.parseCallExpression.bind(this))
this.registerInfix(LBRACKET, this.parseIndexExpression.bind(this))
```

### 2.3.5 普拉特解析法的核心算法

这是整个 Parser 最核心的方法：

```typescript
/**
 * 解析表达式
 *
 * Pratt 解析法的核心实现
 * 使用运算符优先级来正确解析表达式
 *
 * @param precedence - 当前表达式的最低优先级
 * @returns 解析出的表达式节点
 */
private parseExpression(precedence: Precedence): Expression | null {
  // 步骤 1：查找前缀解析函数
  const prefix = this.prefixParseFns.get(this.curToken.Type)
  if (!prefix) {
    this.noPrefixParseFnError(this.curToken.Type)
    return null
  }

  // 步骤 2：调用前缀解析函数，得到左侧表达式
  let leftExp = prefix()
  if (!leftExp) {
    return null
  }

  // 步骤 3：循环处理中缀运算符
  // 只要下一个运算符的优先级更高，就继续解析
  while (
    !this.peekTokenIs(SEMICOLON) &&
    precedence < this.peekPrecedence()
  ) {
    // 查找中缀解析函数
    const infix = this.infixParseFns.get(this.peekToken.Type)
    if (!infix) {
      return leftExp
    }

    // 移动到中缀运算符
    this.nextToken()

    // 调用中缀解析函数，更新左侧表达式
    leftExp = infix(leftExp)
    if (!leftExp) {
      return null
    }
  }

  return leftExp
}
```

#### 算法详解

让我们用 `1 + 2 * 3` 来详细演示这个算法。

**初始状态：**

```
输入: "1 + 2 * 3"
curToken: 1
peekToken: +
```

**执行过程：**

```
第 1 步：parseExpression(LOWEST)
────────────────────────────────
precedence = LOWEST (1)

前缀解析：
  curToken = 1 (INT)
  调用 parseIntegerLiteral()
  leftExp = IntegerLiteral(1)

进入 while 循环：
  peekToken = + (PLUS)
  peekPrecedence = SUM (4)
  LOWEST (1) < SUM (4)? 是，继续

中缀解析：
  nextToken() → curToken = +
  调用 parseInfixExpression(IntegerLiteral(1))

第 2 步：parseInfixExpression(leftExp = IntegerLiteral(1))
──────────────────────────────────────────────────
operator = '+'
curPrecedence = SUM (4)

nextToken() → curToken = 2

解析右侧：
  调用 parseExpression(SUM) // 注意：传入当前优先级

第 3 步：parseExpression(SUM)
────────────────────────────
precedence = SUM (4)

前缀解析：
  curToken = 2 (INT)
  调用 parseIntegerLiteral()
  leftExp = IntegerLiteral(2)

进入 while 循环：
  peekToken = * (ASTERISK)
  peekPrecedence = PRODUCT (5)
  SUM (4) < PRODUCT (5)? 是，继续 ← 关键！

中缀解析：
  nextToken() → curToken = *
  调用 parseInfixExpression(IntegerLiteral(2))

第 4 步：parseInfixExpression(leftExp = IntegerLiteral(2))
──────────────────────────────────────────────────
operator = '*'
curPrecedence = PRODUCT (5)

nextToken() → curToken = 3

解析右侧：
  调用 parseExpression(PRODUCT)

第 5 步：parseExpression(PRODUCT)
───────────────────────────────
precedence = PRODUCT (5)

前缀解析：
  curToken = 3 (INT)
  调用 parseIntegerLiteral()
  leftExp = IntegerLiteral(3)

进入 while 循环：
  peekToken = EOF
  循环结束

返回：IntegerLiteral(3)

第 4 步返回：
─────────────
返回：InfixExpression(2 * 3)
  left = IntegerLiteral(2)
  operator = '*'
  right = IntegerLiteral(3)

第 3 步返回：
─────────────
leftExp = InfixExpression(2 * 3)

继续 while 循环：
  peekToken = EOF
  循环结束

返回：InfixExpression(2 * 3)

第 2 步返回：
─────────────
返回：InfixExpression(1 + (2 * 3))
  left = IntegerLiteral(1)
  operator = '+'
  right = InfixExpression(2 * 3)
```

**最终 AST：**

```
    InfixExpr(+)
    /          \
IntLit(1)   InfixExpr(*)
            /          \
        IntLit(2)   IntLit(3)
```

**关键洞察：**

```
为什么 2 * 3 会先计算？

因为在解析 + 的右侧时，我们传入了 SUM (4) 作为最低优先级。
当看到 * 时，发现 PRODUCT (5) > SUM (4)，所以继续解析，
将 2 * 3 作为一个整体返回。
```

## 2.4 实现语法分析器

### 2.4.1 Parser 类的整体架构

```typescript
/**
 * Parser 类
 *
 * 语法分析器的核心实现
 * 使用 Pratt 解析法构建 AST
 */
export class Parser {
  // 核心状态
  private lexer: Lexer // 词法分析器
  private curToken: Token // 当前 Token
  private peekToken: Token // 下一个 Token (预读)

  // 错误收集
  private errors: string[] = []

  // 解析函数注册表
  private prefixParseFns: Map<TokenType, PrefixParseFn>
  private infixParseFns: Map<TokenType, InfixParseFn>

  /**
   * 构造函数
   */
  constructor(lexer: Lexer) {
    this.lexer = lexer
    this.curToken = { Type: '', Literal: '' }
    this.peekToken = { Type: '', Literal: '' }
    this.prefixParseFns = new Map()
    this.infixParseFns = new Map()

    // 注册所有解析函数
    this.registerParseFunctions()

    // 初始化：读取两个 Token
    this.nextToken()
    this.nextToken()
  }

  /**
   * 解析程序入口
   */
  public parseProgram(): Program {
    const program = new Program()

    while (!this.curTokenIs(EOF)) {
      const stmt = this.parseStatement()
      if (stmt !== null) {
        program.statements.push(stmt)
      }
      this.nextToken()
    }

    return program
  }

  // ... 其他方法 ...
}
```

**为什么需要读取两个 Token？**

```
输入: "let x = 5"

初始化后:
curToken  = LET
peekToken = IDENT (x)

这样我们可以：
1. 知道当前在处理什么 (curToken)
2. 预读下一个 Token (peekToken)
3. 做出决策（比如 '=' 还是 '=='）
```

### 2.4.2 状态管理和错误处理

#### Token 移动

```typescript
/**
 * 移动到下一个 Token
 *
 * 将 peekToken 移动到 curToken
 * 从 lexer 读取新的 peekToken
 */
private nextToken(): void {
  this.curToken = this.peekToken
  this.peekToken = this.lexer.nextToken()
}

/**
 * 检查当前 Token 是否为指定类型
 */
private curTokenIs(t: TokenType): boolean {
  return this.curToken.Type === t
}

/**
 * 检查下一个 Token 是否为指定类型
 */
private peekTokenIs(t: TokenType): boolean {
  return this.peekToken.Type === t
}
```

#### 期望 Token

```typescript
/**
 * 期望下一个 Token 为指定类型
 *
 * 如果是，则前进一个 Token 并返回 true
 * 如果不是，则记录错误并返回 false
 *
 * @param t - 期望的 Token 类型
 * @returns 是否符合期望
 */
private expectPeek(t: TokenType): boolean {
  if (this.peekTokenIs(t)) {
    this.nextToken()
    return true
  }
  this.peekError(t)
  return false
}
```

**使用示例：**

```typescript
// 解析 let 语句
private parseLetStatement(): LetStatement | null {
  const stmtToken = this.curToken

  // 期望下一个是标识符
  if (!this.expectPeek(IDENT)) {
    return null // 返回 null 表示解析失败
  }

  const name = new Identifier(this.curToken, this.curToken.Literal)

  // 期望下一个是 =
  if (!this.expectPeek(ASSIGN)) {
    return null
  }

  // ... 继续解析 ...
}
```

#### 错误处理

```typescript
/**
 * 记录期望 Token 类型不匹配的错误
 */
private peekError(t: TokenType): void {
  const msg = `expected next token to be ${t}, got ${this.peekToken.Type} instead`
  this.errors.push(msg)
}

/**
 * 记录没有找到前缀解析函数的错误
 */
private noPrefixParseFnError(t: TokenType): void {
  const msg = `no prefix parse function for ${t} found`
  this.errors.push(msg)
}

/**
 * 获取所有错误
 */
public getErrors(): string[] {
  return this.errors
}
```

**错误恢复策略：**

```typescript
// 当遇到错误时，跳过当前语句
if (!this.expectPeek(ASSIGN)) {
  // 记录错误
  // 返回 null
  // parseProgram 会继续处理下一个语句
  return null
}
```

### 2.4.3 解析函数注册机制

```typescript
/**
 * 注册前缀解析函数
 */
private registerPrefix(tokenType: TokenType, fn: PrefixParseFn): void {
  this.prefixParseFns.set(tokenType, fn)
}

/**
 * 注册中缀解析函数
 */
private registerInfix(tokenType: TokenType, fn: InfixParseFn): void {
  this.infixParseFns.set(tokenType, fn)
}

/**
 * 注册所有解析函数
 */
private registerParseFunctions(): void {
  // 前缀解析函数
  this.registerPrefix(IDENT, this.parseIdentifier.bind(this))
  this.registerPrefix(INT, this.parseIntegerLiteral.bind(this))
  this.registerPrefix(STRING, this.parseStringLiteral.bind(this))
  this.registerPrefix(BANG, this.parsePrefixExpression.bind(this))
  this.registerPrefix(MINUS, this.parsePrefixExpression.bind(this))
  this.registerPrefix(TRUE, this.parseBoolean.bind(this))
  this.registerPrefix(FALSE, this.parseBoolean.bind(this))
  this.registerPrefix(LPAREN, this.parseGroupedExpression.bind(this))
  this.registerPrefix(IF, this.parseIfExpression.bind(this))
  this.registerPrefix(FUNCTION, this.parseFunctionLiteral.bind(this))
  this.registerPrefix(LBRACKET, this.parseArrayLiteral.bind(this))
  this.registerPrefix(LBRACE, this.parseHashLiteral.bind(this))

  // 中缀解析函数
  this.registerInfix(PLUS, this.parseInfixExpression.bind(this))
  this.registerInfix(MINUS, this.parseInfixExpression.bind(this))
  this.registerInfix(SLASH, this.parseInfixExpression.bind(this))
  this.registerInfix(ASTERISK, this.parseInfixExpression.bind(this))
  this.registerInfix(EQ, this.parseInfixExpression.bind(this))
  this.registerInfix(NOT_EQ, this.parseInfixExpression.bind(this))
  this.registerInfix(LT, this.parseInfixExpression.bind(this))
  this.registerInfix(GT, this.parseInfixExpression.bind(this))
  this.registerInfix(LPAREN, this.parseCallExpression.bind(this))
  this.registerInfix(LBRACKET, this.parseIndexExpression.bind(this))
}
```

**为什么使用 bind(this)？**

```typescript
// ❌ 不使用 bind，this 会丢失
this.registerPrefix(INT, this.parseIntegerLiteral)
// 调用时 this 不是 Parser 实例

// ✅ 使用 bind，绑定 this
this.registerPrefix(INT, this.parseIntegerLiteral.bind(this))
// 调用时 this 始终是 Parser 实例
```

## 2.5 解析语句

### 2.5.1 解析 let 语句

**语法：** `let <identifier> = <expression>;`

```typescript
/**
 * 解析 let 语句
 *
 * 格式：let <identifier> = <expression>;
 *
 * 示例：
 * let x = 5;
 * let add = fn(a, b) { a + b };
 */
private parseLetStatement(): LetStatement | null {
  // 保存 LET token
  const stmtToken = this.curToken

  // 期望下一个 Token 是标识符
  if (!this.expectPeek(IDENT)) {
    return null
  }

  // 创建标识符节点
  const name = new Identifier(this.curToken, this.curToken.Literal)

  // 期望下一个 Token 是赋值符号
  if (!this.expectPeek(ASSIGN)) {
    return null
  }

  // 移动到表达式的第一个 Token
  this.nextToken()

  // 解析赋值表达式
  const value = this.parseExpression(Precedence.LOWEST)
  if (!value) {
    return null
  }

  // 可选的分号
  if (this.peekTokenIs(SEMICOLON)) {
    this.nextToken()
  }

  // 构造 LetStatement 节点
  return new LetStatement(stmtToken, name, value)
}
```

**执行过程示例：**

```
输入: "let x = 5 + 3;"

Token 流:
[LET] [IDENT:x] [=] [INT:5] [+] [INT:3] [;]

执行过程:
curToken = LET, peekToken = IDENT

1. stmtToken = LET

2. expectPeek(IDENT)
   → curToken = IDENT (x), peekToken = =
   → name = Identifier("x")

3. expectPeek(ASSIGN)
   → curToken = =, peekToken = INT (5)

4. nextToken()
   → curToken = INT (5), peekToken = +

5. parseExpression(LOWEST)
   → 返回 InfixExpression(5 + 3)

6. peekToken = ;, 跳过分号

7. 返回 LetStatement {
     name: Identifier("x"),
     value: InfixExpression(5 + 3)
   }
```

### 2.5.2 解析 return 语句

**语法：** `return <expression>;`

```typescript
/**
 * 解析 return 语句
 *
 * 格式：return <expression>;
 *
 * 示例：
 * return 5;
 * return x + y;
 */
private parseReturnStatement(): ReturnStatement | null {
  // 保存 RETURN token
  const stmtToken = this.curToken

  // 移动到返回值表达式
  this.nextToken()

  // 解析返回值表达式
  const returnValue = this.parseExpression(Precedence.LOWEST)
  if (!returnValue) {
    return null
  }

  // 可选的分号
  if (this.peekTokenIs(SEMICOLON)) {
    this.nextToken()
  }

  return new ReturnStatement(stmtToken, returnValue)
}
```

### 2.5.3 解析表达式语句

**语法：** `<expression>;`

```typescript
/**
 * 解析表达式语句
 *
 * 格式：<expression>;
 *
 * 在 Monkey 中，表达式可以作为语句
 * 例如：5 + 3;  调用函数但不使用返回值
 */
private parseExpressionStatement(): ExpressionStatement | null {
  const stmtToken = this.curToken

  // 解析表达式
  const expression = this.parseExpression(Precedence.LOWEST)
  if (!expression) {
    return null
  }

  // 可选的分号
  if (this.peekTokenIs(SEMICOLON)) {
    this.nextToken()
  }

  return new ExpressionStatement(stmtToken, expression)
}
```

### 2.5.4 解析代码块

**语法：** `{ <statement>* }`

```typescript
/**
 * 解析代码块
 *
 * 格式：{ <statement>* }
 *
 * 用于函数体、if 的 consequence/alternative
 */
private parseBlockStatement(): BlockStatement {
  // 保存 { token
  const block = new BlockStatement(this.curToken)
  block.statements = []

  // 移动到代码块的第一个语句
  this.nextToken()

  // 持续解析语句直到遇到 } 或 EOF
  while (!this.curTokenIs(RBRACE) && !this.curTokenIs(EOF)) {
    const stmt = this.parseStatement()
    if (stmt !== null) {
      block.statements.push(stmt)
    }
    this.nextToken()
  }

  return block
}
```

**执行过程示例：**

```
输入: "{ let x = 5; return x; }"

Token 流:
[{] [LET] [IDENT:x] [=] [INT:5] [;] [RETURN] [IDENT:x] [;] [}]

执行过程:
curToken = {

1. block = BlockStatement({)

2. nextToken()
   curToken = LET

3. while (!curTokenIs(RBRACE))
   parseStatement()
   → LetStatement

4. nextToken()
   curToken = RETURN

5. while (!curTokenIs(RBRACE))
   parseStatement()
   → ReturnStatement

6. nextToken()
   curToken = }

7. while (!curTokenIs(RBRACE)) = false
   退出循环

8. 返回 BlockStatement {
     statements: [
       LetStatement,
       ReturnStatement
     ]
   }
```

## 2.6 解析表达式

### 2.6.1 解析字面量

#### 解析整数字面量

```typescript
/**
 * 解析整数字面量
 */
private parseIntegerLiteral(): Expression | null {
  // 将字符串转换为数字
  const value = parseInt(this.curToken.Literal, 10)

  // 检查转换是否成功
  if (isNaN(value)) {
    const msg = `could not parse ${this.curToken.Literal} as integer`
    this.errors.push(msg)
    return null
  }

  return new IntegerLiteral(this.curToken, value)
}
```

#### 解析字符串字面量

```typescript
/**
 * 解析字符串字面量
 */
private parseStringLiteral(): Expression {
  return new StringLiteral(this.curToken, this.curToken.Literal)
}
```

#### 解析布尔字面量

```typescript
/**
 * 解析布尔值
 */
private parseBoolean(): Expression {
  return new BooleanLiteral(
    this.curToken,
    this.curTokenIs(TRUE)
  )
}
```

#### 解析标识符

```typescript
/**
 * 解析标识符
 */
private parseIdentifier(): Expression {
  return new Identifier(this.curToken, this.curToken.Literal)
}
```

### 2.6.2 解析前缀表达式

**语法：** `<operator><expression>`

```typescript
/**
 * 解析前缀表达式
 *
 * 格式：<operator><expression>
 * 例如：-5, !true
 */
private parsePrefixExpression(): Expression | null {
  // 保存运算符 token 和运算符字符串
  const exprToken = this.curToken
  const operator = this.curToken.Literal

  // 移动到右侧表达式
  this.nextToken()

  // 以 PREFIX 优先级解析右侧表达式
  const right = this.parseExpression(Precedence.PREFIX)
  if (!right) {
    return null
  }

  return new PrefixExpression(exprToken, operator, right)
}
```

**为什么使用 PREFIX 优先级？**

```monkey
-5 + 3
```

**正确的理解：**

```
    +
   / \
  -   3
  |
  5
```

**执行过程：**

```
解析 -5 + 3

1. parsePrefixExpression()
   operator = '-'
   nextToken() → curToken = 5

2. parseExpression(PREFIX)
   PREFIX (6) 的优先级很高
   只会解析 5，不会解析 + 3
   返回 IntegerLiteral(5)

3. 返回 PrefixExpression(-5)

4. 继续解析，发现 + (优先级 SUM = 4 < PREFIX = 6)
   所以 -5 作为整体成为 + 的左侧
```

### 2.6.3 解析中缀表达式

**语法：** `<expression> <operator> <expression>`

```typescript
/**
 * 解析中缀表达式
 *
 * 格式：<expression> <operator> <expression>
 * 例如：5 + 3, x * y
 */
private parseInfixExpression(left: Expression): Expression | null {
  // 保存运算符信息
  const exprToken = this.curToken
  const operator = this.curToken.Literal

  // 获取当前运算符的优先级
  const precedence = this.curPrecedence()

  // 移动到右侧表达式
  this.nextToken()

  // 以当前优先级解析右侧表达式
  const right = this.parseExpression(precedence)
  if (!right) {
    return null
  }

  return new InfixExpression(exprToken, left, operator, right)
}
```

**左结合 vs 右结合：**

```monkey
// 左结合（大多数运算符）
1 + 2 + 3 === (1 + 2) + 3

// 如果是右结合（赋值运算符）
a = b = c === a = (b = c)
```

Monkey 的所有中缀运算符都是左结合的，这是通过传递当前优先级（而不是当前优先级+1）实现的。

### 2.6.4 解析 if 表达式

**语法：** `if (<condition>) { <consequence> } else { <alternative> }`

```typescript
/**
 * 解析 if 表达式
 *
 * 格式：if (<condition>) { <consequence> } else { <alternative> }
 * else 部分是可选的
 */
private parseIfExpression(): Expression | null {
  const exprToken = this.curToken

  // 期望左括号
  if (!this.expectPeek(LPAREN)) {
    return null
  }

  // 移动到条件表达式
  this.nextToken()

  // 解析条件表达式
  const condition = this.parseExpression(Precedence.LOWEST)
  if (!condition) {
    return null
  }

  // 期望右括号
  if (!this.expectPeek(RPAREN)) {
    return null
  }

  // 期望左花括号
  if (!this.expectPeek(LBRACE)) {
    return null
  }

  // 解析 consequence 代码块
  const consequence = this.parseBlockStatement()

  let alternative: BlockStatement | undefined

  // 检查是否有 else 分支
  if (this.peekTokenIs(ELSE)) {
    this.nextToken() // 移动到 ELSE

    // 期望左花括号
    if (!this.expectPeek(LBRACE)) {
      return null
    }

    // 解析 alternative 代码块
    alternative = this.parseBlockStatement()
  }

  return new IfExpression(exprToken, condition, consequence, alternative)
}
```

**执行过程示例：**

```
输入: "if (x > 5) { return true; } else { return false; }"

Token 流:
[IF] [(] [IDENT:x] [>] [INT:5] [)] [{] [RETURN] [TRUE] [;] [}] [ELSE] [{] [RETURN] [FALSE] [;] [}]

执行过程:
curToken = IF

1. exprToken = IF

2. expectPeek(LPAREN)
   curToken = (

3. nextToken()
   curToken = IDENT (x)

4. condition = parseExpression(LOWEST)
   → InfixExpression(x > 5)

5. expectPeek(RPAREN)
   curToken = )

6. expectPeek(LBRACE)
   curToken = {

7. consequence = parseBlockStatement()
   → BlockStatement([ReturnStatement(true)])

8. peekToken = ELSE
   nextToken() → curToken = ELSE

9. expectPeek(LBRACE)
   curToken = {

10. alternative = parseBlockStatement()
    → BlockStatement([ReturnStatement(false)])

11. 返回 IfExpression {
      condition: InfixExpression(x > 5),
      consequence: BlockStatement([...]),
      alternative: BlockStatement([...])
    }
```

### 2.6.5 解析函数字面量

**语法：** `fn(<parameters>) { <body> }`

```typescript
/**
 * 解析函数字面量
 *
 * 格式：fn(<parameters>) { <body> }
 */
private parseFunctionLiteral(): Expression | null {
  const litToken = this.curToken

  // 期望左括号
  if (!this.expectPeek(LPAREN)) {
    return null
  }

  // 解析参数列表
  const parameters = this.parseFunctionParameters()
  if (parameters === null) {
    return null
  }

  // 期望左花括号
  if (!this.expectPeek(LBRACE)) {
    return null
  }

  // 解析函数体
  const body = this.parseBlockStatement()

  // 构造函数字面量节点
  const func = new FunctionLiteral(litToken, body)
  func.parameters = parameters
  return func
}

/**
 * 解析函数参数列表
 *
 * 格式：(<identifier>, <identifier>, ...)
 */
private parseFunctionParameters(): Identifier[] | null {
  const identifiers: Identifier[] = []

  // 空参数列表
  if (this.peekTokenIs(RPAREN)) {
    this.nextToken()
    return identifiers
  }

  // 第一个参数
  this.nextToken()
  identifiers.push(new Identifier(this.curToken, this.curToken.Literal))

  // 其余参数
  while (this.peekTokenIs(COMMA)) {
    this.nextToken() // 跳过逗号
    this.nextToken() // 移动到参数
    identifiers.push(new Identifier(this.curToken, this.curToken.Literal))
  }

  // 期望右括号
  if (!this.expectPeek(RPAREN)) {
    return null
  }

  return identifiers
}
```

### 2.6.6 解析函数调用

**语法：** `<expression>(<arguments>)`

```typescript
/**
 * 解析函数调用表达式
 *
 * 格式：<expression>(<arguments>)
 * 例如：add(1, 2), myFunction(x, y, z)
 */
private parseCallExpression(func: Expression): Expression | null {
  // 保存 ( token
  const exp = new CallExpression(this.curToken, func)

  // 解析参数列表
  const args = this.parseExpressionList(RPAREN)
  if (args === null) {
    return null
  }

  exp.args = args
  return exp
}

/**
 * 解析表达式列表
 *
 * 用于解析函数参数或数组元素
 * @param end - 结束 Token 类型（RPAREN 或 RBRACKET）
 */
private parseExpressionList(end: TokenType): Expression[] | null {
  const list: Expression[] = []

  // 空列表
  if (this.peekTokenIs(end)) {
    this.nextToken()
    return list
  }

  // 第一个表达式
  this.nextToken()
  const firstExpr = this.parseExpression(Precedence.LOWEST)
  if (!firstExpr) {
    return null
  }
  list.push(firstExpr)

  // 其余表达式
  while (this.peekTokenIs(COMMA)) {
    this.nextToken() // 跳过逗号
    this.nextToken() // 移动到表达式
    const expr = this.parseExpression(Precedence.LOWEST)
    if (!expr) {
      return null
    }
    list.push(expr)
  }

  // 期望结束 token
  if (!this.expectPeek(end)) {
    return null
  }

  return list
}
```

**为什么 `(` 是中缀运算符？**

```monkey
add(1, 2)
^   ^
|   └── ( 是中缀运算符
└────── 左侧表达式
```

`(` 出现在表达式之后，所以它是中缀运算符。函数调用的优先级很高（CALL = 7），所以：

```monkey
add(1, 2) * 3
```

会被解析为：

```
    *
   / \
 call  3
  / \
add (1,2)
```

## 2.7 完整示例和调试

### 示例 1：简单算术表达式

```typescript
import { Lexer } from './lexer/lexer'
import { Parser } from './parser/parser'

const input = '5 + 5 * 2'
const lexer = new Lexer(input)
const parser = new Parser(lexer)

const program = parser.parseProgram()

// 检查错误
if (parser.getErrors().length > 0) {
  console.error('解析错误:', parser.getErrors())
} else {
  console.log(program.toString())
  // 输出: (5 + (5 * 2))
}
```

### 示例 2：复杂表达式

```typescript
const input = `
let x = 10;
let y = 15;
let add = fn(a, b) {
  return a + b;
};
add(x, y);
`

const lexer = new Lexer(input)
const parser = new Parser(lexer)
const program = parser.parseProgram()

console.log('AST:', JSON.stringify(program, null, 2))
```

### 调试技巧

#### 1. 打印 Token 流

```typescript
// 先看看 Lexer 产生了什么
const lexer = new Lexer(input)
let tok = lexer.nextToken()
while (tok.Type !== EOF) {
  console.log(tok)
  tok = lexer.nextToken()
}
```

#### 2. 打印 AST

```typescript
// 使用 toString 方法
console.log(program.toString())

// 或使用 JSON 序列化
console.log(JSON.stringify(program, null, 2))
```

#### 3. 逐步调试

```typescript
// 在关键位置添加日志
private parseExpression(precedence: Precedence): Expression | null {
  console.log(`parseExpression: precedence=${precedence}, curToken=${this.curToken.Type}`)

  const prefix = this.prefixParseFns.get(this.curToken.Type)
  // ...
}
```

## 2.8 测试策略

### 测试用例设计

```typescript
import { describe, it, expect } from 'vitest'
import { Lexer } from '../lexer/lexer'
import { Parser } from './parser'
import * as ast from '../ast/ast'

describe('Parser', () => {
  it('应该正确解析 let 语句', () => {
    const input = `
      let x = 5;
      let y = 10;
      let foobar = 838383;
    `

    const lexer = new Lexer(input)
    const parser = new Parser(lexer)
    const program = parser.parseProgram()

    checkParserErrors(parser)

    expect(program.statements.length).toBe(3)

    const tests = ['x', 'y', 'foobar']

    for (let i = 0; i < tests.length; i++) {
      const stmt = program.statements[i]
      expect(stmt).toBeInstanceOf(ast.LetStatement)
      const letStmt = stmt as ast.LetStatement
      expect(letStmt.name.value).toBe(tests[i])
    }
  })

  it('应该正确处理运算符优先级', () => {
    const tests = [
      { input: '1 + 2 * 3', expected: '(1 + (2 * 3))' },
      { input: '(1 + 2) * 3', expected: '((1 + 2) * 3)' },
      { input: '-a * b', expected: '((-a) * b)' },
      { input: '!-a', expected: '(!(-a))' },
      { input: 'a + b + c', expected: '((a + b) + c)' },
      { input: 'a * b * c', expected: '((a * b) * c)' },
      {
        input: 'a + b * c + d / e - f',
        expected: '(((a + (b * c)) + (d / e)) - f)',
      },
    ]

    for (const tt of tests) {
      const lexer = new Lexer(tt.input)
      const parser = new Parser(lexer)
      const program = parser.parseProgram()

      checkParserErrors(parser)

      const actual = program.toString()
      expect(actual).toBe(tt.expected)
    }
  })

  it('应该正确解析函数字面量', () => {
    const input = 'fn(x, y) { x + y; }'

    const lexer = new Lexer(input)
    const parser = new Parser(lexer)
    const program = parser.parseProgram()

    checkParserErrors(parser)

    expect(program.statements.length).toBe(1)

    const stmt = program.statements[0] as ast.ExpressionStatement
    const func = stmt.expression as ast.FunctionLiteral

    expect(func.parameters.length).toBe(2)
    expect(func.parameters[0].value).toBe('x')
    expect(func.parameters[1].value).toBe('y')
  })
})

// 辅助函数：检查解析错误
function checkParserErrors(parser: Parser) {
  const errors = parser.getErrors()
  if (errors.length === 0) {
    return
  }

  console.error('Parser has errors:')
  for (const error of errors) {
    console.error(`\t${error}`)
  }

  throw new Error('Parser errors')
}
```

## 2.9 常见问题和陷阱

### 1. 忘记调用 bind(this)

```typescript
// ❌ 错误
this.registerPrefix(INT, this.parseIntegerLiteral)

// ✅ 正确
this.registerPrefix(INT, this.parseIntegerLiteral.bind(this))
```

### 2. 优先级设置错误

```typescript
// ❌ 错误：所有运算符优先级相同
const precedences = {
  [PLUS]: Precedence.SUM,
  [ASTERISK]: Precedence.SUM, // 应该是 PRODUCT
}
```

### 3. 递归深度问题

```monkey
// 极深的嵌套可能导致堆栈溢出
1 + 1 + 1 + 1 + 1 + ... (成千上万个)
```

**解决方案：** 使用迭代而非递归（Pratt 解析法的 while 循环已经这样做了）

### 4. 错误恢复不当

```typescript
// ❌ 错误：遇到错误后立即返回
if (!this.expectPeek(ASSIGN)) {
  throw new Error('Expected =')
}

// ✅ 正确：记录错误并继续
if (!this.expectPeek(ASSIGN)) {
  this.peekError(ASSIGN)
  return null
}
```

## 小结

在本章中，我们深入学习了：

### 核心概念

- **语法分析的任务**：将 Token 流转换为 AST
- **AST 的本质**：源代码的树形表示
- **Statement vs Expression**：执行操作 vs 产生值
- **普拉特解析法**：优雅地处理运算符优先级

### 实现技术

- **运算符优先级**：使用数字表示优先级，指导解析顺序
- **前缀解析函数**：处理表达式开始位置的 Token
- **中缀解析函数**：处理两个表达式之间的 Token
- **解析函数注册表**：使用 Map 存储解析函数，易于扩展

### 设计原则

- **关注点分离**：每个节点类型有明确的职责
- **类型安全**：利用 TypeScript 的类型系统
- **错误处理**：收集错误而不是立即崩溃
- **可扩展性**：添加新语法结构很简单

### 关键算法

**Pratt 解析法的核心思想：**

```
1. 调用前缀解析函数获取左侧表达式
2. 循环检查下一个运算符的优先级
3. 如果优先级更高，调用中缀解析函数
4. 中缀解析函数递归调用 parseExpression，传入当前优先级
5. 这样自然形成了正确的 AST 结构
```

语法分析器为我们提供了程序的结构化表示，这是理解和执行代码的关键。在下一章中，我们将学习如何遍历 AST 并执行代码。

---

**上一章**：[第一章：词法分析](./01-词法分析.md)

**下一章**：[第三章：求值](./03-求值.md)

**源代码参考**：

- [ast.ts](../src/monkey/ast/ast.ts) - AST 节点定义
- [parser.ts](../src/monkey/parser/parser.ts) - Parser 实现
- [parser.test.ts](../src/monkey/parser/parser.test.ts) - 测试用例

**推荐阅读**：

- 《编译原理》（龙书）第 4 章：语法分析
- [Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html) - Alexey Kladov 的文章
- [Top Down Operator Precedence](http://crockford.com/javascript/tdop/tdop.html) - Douglas Crockford
