# 第二章：语法分析

## 目录

- [2.1 语法分析简介](#21-语法分析简介)
- [2.2 抽象语法树（AST）](#22-抽象语法树ast)
- [2.3 解析策略：普拉特解析法](#23-解析策略普拉特解析法)
- [2.4 实现语法分析器](#24-实现语法分析器)
- [2.5 解析语句](#25-解析语句)
- [2.6 解析表达式](#26-解析表达式)
- [2.7 完整示例](#27-完整示例)

## 2.1 语法分析简介

语法分析（Parsing）是解释器的第二步。它的任务是将词法单元流转换为 **抽象语法树（Abstract Syntax Tree, AST）**。

### 从词法单元到抽象语法树

在上一章中，我们将源代码转换为词法单元流：

```
let x = 5 + 5;
↓
[LET] [IDENT:x] [=] [INT:5] [+] [INT:5] [;]
```

现在，Parser 需要理解这些词法单元的结构关系，构建成树形结构：

```
Program
└── LetStatement
    ├── name: Identifier(x)
    └── value: InfixExpression
        ├── left: IntegerLiteral(5)
        ├── operator: "+"
        └── right: IntegerLiteral(5)
```

### 为什么需要抽象语法树？

1. **结构化表示**：树形结构清晰地表达了代码的语法结构
2. **便于处理**：求值器可以递归遍历树来执行代码
3. **类型安全**：TypeScript 的类型系统可以帮助我们确保正确性
4. **可扩展性**：添加新的语法结构只需要添加新的 AST 节点类型

## 2.2 抽象语法树（AST）

### 抽象语法树节点的层次结构

Monkey 的抽象语法树有以下层次结构：

```
Node（所有节点的基础接口）
├── Statement（语句）
│   ├── LetStatement（变量声明）
│   ├── ReturnStatement（返回语句）
│   ├── ExpressionStatement（表达式语句）
│   └── BlockStatement（代码块）
└── Expression（表达式）
    ├── Identifier（标识符）
    ├── IntegerLiteral（整数字面量）
    ├── StringLiteral（字符串字面量）
    ├── BooleanLiteral（布尔值）
    ├── ArrayLiteral（数组）
    ├── HashLiteral（哈希表）
    ├── PrefixExpression（前缀表达式）
    ├── InfixExpression（中缀表达式）
    ├── IfExpression（条件表达式）
    ├── FunctionLiteral（函数）
    ├── CallExpression（函数调用）
    └── IndexExpression（索引访问）
```

### 基础接口

所有 AST 节点都实现 `Node` 接口：

```typescript
export interface Node {
  tokenLiteral(): string
  toString(): string
}
```

### 语句和表达式

- **Statement（语句）**：执行操作但不产生值
- **Expression（表达式）**：会计算并产生值

## 2.3 解析策略：普拉特解析法

普拉特解析法（Pratt Parsing）是一种优雅的表达式解析技术。

### 为什么选择普拉特解析法？

1. **简洁高效**：代码量少，易于理解
2. **易于扩展**：添加新运算符只需注册解析函数
3. **处理优先级**：自然地处理运算符优先级
4. **支持多种表达式**：前缀、中缀、后缀都可以处理

### 核心概念

#### 运算符优先级

```typescript
const enum Precedence {
  LOWEST = 1,
  EQUALS, // == 或 !=
  LESSGREATER, // < 或 >
  SUM, // + 或 -
  PRODUCT, // * 或 /
  PREFIX, // -X 或 !X
  CALL, // myFunction(X)
  INDEX, // array[index]
}
```

#### 前缀和中缀解析函数

- **前缀解析函数**：解析前缀位置的表达式（如 `-5`、`(1+2)`）
- **中缀解析函数**：解析中缀位置的表达式（如 `5+3`、`add(1,2)`）

## 2.4 实现语法分析器

### 语法分析器类的结构

```typescript
export class Parser {
  private lexer: Lexer
  private errors: string[] = []
  private curToken: Token
  private peekToken: Token
  private prefixParseFns: Map<TokenType, PrefixParseFn>
  private infixParseFns: Map<TokenType, InfixParseFn>

  constructor(lexer: Lexer) {
    this.lexer = lexer
    // 初始化...
    // 注册解析函数...
    this.nextToken()
    this.nextToken()
  }

  public parseProgram(): Program {
    const program = new Program()
    while (!this.curTokenIs(EOF)) {
      const stmt = this.parseStatement()
      if (stmt !== null) {
        program.statements.push(stmt)
      }
      this.nextToken()
    }
    return program
  }
}
```

## 2.5 解析语句

### 解析语句的入口

```typescript
private parseStatement(): Statement | null {
  switch (this.curToken.Type) {
    case LET:
      return this.parseLetStatement();
    case RETURN:
      return this.parseReturnStatement();
    default:
      return this.parseExpressionStatement();
  }
}
```

### 解析 let 语句

格式：`let <identifier> = <expression>;`

```typescript
private parseLetStatement(): LetStatement | null {
  const stmtToken = this.curToken;

  if (!this.expectPeek(IDENT)) {
    return null;
  }

  const name = new Identifier(this.curToken, this.curToken.Literal);

  if (!this.expectPeek(ASSIGN)) {
    return null;
  }

  this.nextToken();
  const value = this.parseExpression(Precedence.LOWEST);

  if (this.peekTokenIs(SEMICOLON)) {
    this.nextToken();
  }

  return new LetStatement(stmtToken, name, value);
}
```

## 2.6 解析表达式

### 核心方法：解析表达式

这是普拉特解析法的核心：

```typescript
private parseExpression(precedence: Precedence): Expression | null {
  // 1. 查找前缀解析函数
  const prefix = this.prefixParseFns.get(this.curToken.Type);
  if (!prefix) {
    return null;
  }

  // 2. 调用前缀解析函数
  let leftExp = prefix();

  // 3. 当下一个运算符优先级更高时，继续解析
  while (!this.peekTokenIs(SEMICOLON) && precedence < this.peekPrecedence()) {
    const infix = this.infixParseFns.get(this.peekToken.Type);
    if (!infix) {
      return leftExp;
    }
    this.nextToken();
    leftExp = infix(leftExp);
  }

  return leftExp;
}
```

## 2.7 完整示例

### 示例 1：算术表达式

```typescript
const input = '5 + 5 * 2'
const lexer = new Lexer(input)
const parser = new Parser(lexer)
const program = parser.parseProgram()
console.log(program.toString()) // "(5 + (5 * 2))"
```

### 示例 2：函数定义

```typescript
const input = `
let add = fn(x, y) {
  return x + y;
};
`
const lexer = new Lexer(input)
const parser = new Parser(lexer)
const program = parser.parseProgram()
```

## 小结

在本章中，我们学习了：

1. **抽象语法树的概念**：树形结构表示代码的语法结构
2. **抽象语法树节点的设计**：语句和表达式的区分
3. **普拉特解析法**：运算符优先级、前缀和中缀解析函数
4. **语法分析器的实现**：解析语句和表达式

语法分析器为我们提供了程序的结构化表示，这为下一步的求值奠定了基础。

---

**上一章**：[第一章：词法分析](./01-lexing.md)

**下一章**：[第三章：求值](./03-evaluation.md)

**源代码参考**：

- [ast.ts](../src/monkey/ast/ast.ts)
- [parser.ts](../src/monkey/parser/parser.ts)
