# 第四章：扩展解释器

> "语言的力量来自于它的可组合性。" —— Structure and Interpretation of Computer Programs

## 目录

- [4.1 扩展概览](#41-扩展概览)
- [4.2 数据结构](#42-数据结构)
  - [4.2.1 数组（Arrays）](#421-数组arrays)
  - [4.2.2 哈希表（Hash Maps）](#422-哈希表hash-maps)
  - [4.2.3 索引表达式](#423-索引表达式)
- [4.3 字符串操作](#43-字符串操作)
- [4.4 内置函数详解](#44-内置函数详解)
  - [4.4.1 数组操作函数](#441-数组操作函数)
  - [4.4.2 输入输出函数](#442-输入输出函数)
- [4.5 高级特性](#45-高级特性)
  - [4.5.1 高阶函数](#451-高阶函数)
  - [4.5.2 闭包应用](#452-闭包应用)
  - [4.5.3 递归技巧](#453-递归技巧)
- [4.6 实战示例](#46-实战示例)
- [4.7 可能的扩展方向](#47-可能的扩展方向)

---

## 4.1 扩展概览

在前三章中，我们实现了一个基础的 Monkey 解释器。现在让我们扩展它的功能，添加更强大的数据结构和操作。

### 已实现的核心功能

✅ 基本数据类型：整数、布尔值、字符串
✅ 变量绑定：let 语句
✅ 函数：fn 关键字、函数调用、闭包
✅ 运算符：算术、比较、逻辑
✅ 控制流：if-else 表达式
✅ 返回语句

### 本章新增功能

🆕 **数组**：有序集合 `[1, 2, 3]`
🆕 **哈希表**：键值对映射 `{"name": "Monkey"}`
🆕 **索引访问**：`arr[0]`, `hash["key"]`
🆕 **字符串拼接**：`"hello" + " world"`
🆕 **内置函数**：`len`, `first`, `last`, `rest`, `push`, `puts`

## 4.2 数据结构

### 4.2.1 数组（Arrays）

#### 数组的语法

```monkey
// 字面量创建
let myArray = [1, 2, 3, 4, 5];

// 混合类型
let mixed = [1, "hello", true, fn(x) { x }];

// 嵌套数组
let matrix = [[1, 2], [3, 4], [5, 6]];

// 空数组
let empty = [];
```

#### AST 表示

```typescript
/**
 * ArrayLiteral 类
 *
 * 表示数组字面量
 * 语法：[<expression>, <expression>, ...]
 */
export class ArrayLiteral implements Expression {
  token: Token // [ token
  elements: Expression[] // 元素表达式列表

  constructor(token: Token, elements: Expression[]) {
    this.token = token
    this.elements = elements
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    const elements = this.elements.map((el) => el.toString()).join(', ')
    return `[${elements}]`
  }
}
```

#### 解析数组字面量

```typescript
/**
 * 解析数组字面量
 *
 * 当前 Token 是 [
 */
private parseArrayLiteral(): Expression | null {
  const token = this.curToken

  // 解析元素列表（使用通用的表达式列表解析函数）
  const elements = this.parseExpressionList(RBRACKET)
  if (elements === null) {
    return null
  }

  return new ArrayLiteral(token, elements)
}
```

#### 求值数组字面量

```typescript
/**
 * 求值数组字面量
 */
function evalArrayLiteral(node: ArrayLiteral, env: Environment): MonkeyObject {
  // 依次求值所有元素
  const elements = evalExpressions(node.elements, env)

  // 检查是否有错误
  if (elements.length === 1 && isError(elements[0])) {
    return elements[0]
  }

  // 创建数组对象
  return new ArrayObject(elements)
}
```

#### 数组的运行时表示

```typescript
/**
 * ArrayObject 类
 *
 * 表示运行时的数组对象
 */
export class ArrayObject implements MonkeyObject {
  elements: MonkeyObject[]

  constructor(elements: MonkeyObject[]) {
    this.elements = elements
  }

  type(): ObjectType {
    return ARRAY_OBJ
  }

  inspect(): string {
    const elements = this.elements.map((e) => e.inspect()).join(', ')
    return `[${elements}]`
  }
}
```

#### 数组操作示例

```monkey
let arr = [1, 2, 3];

// 访问元素
arr[0];        // 1
arr[1];        // 2
arr[2];        // 3

// 获取长度
len(arr);      // 3

// 第一个元素
first(arr);    // 1

// 最后一个元素
last(arr);     // 3

// 去掉第一个元素
rest(arr);     // [2, 3]

// 添加元素（返回新数组）
push(arr, 4);  // [1, 2, 3, 4]
```

### 4.2.2 哈希表（Hash Maps）

#### 哈希表的语法

```monkey
// 字面量创建
let myHash = {"name": "Monkey", "age": 1};

// 数字键
let numberKeys = {1: "one", 2: "two", 3: "three"};

// 布尔键
let boolKeys = {true: "yes", false: "no"};

// 混合值类型
let mixed = {
  "name": "Monkey",
  "age": 1,
  "hobbies": ["programming", "bananas"]
};

// 空哈希表
let empty = {};
```

#### AST 表示

```typescript
/**
 * HashLiteral 类
 *
 * 表示哈希表字面量
 * 语法：{<expression>: <expression>, ...}
 */
export class HashLiteral implements Expression {
  token: Token // { token
  pairs: Map<Expression, Expression> // 键值对映射

  constructor(token: Token, pairs: Map<Expression, Expression>) {
    this.token = token
    this.pairs = pairs
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    const pairs: string[] = []
    for (const [key, value] of this.pairs) {
      pairs.push(`${key.toString()}:${value.toString()}`)
    }
    return `{${pairs.join(', ')}}`
  }
}
```

#### 解析哈希表字面量

```typescript
/**
 * 解析哈希表字面量
 *
 * 当前 Token 是 {
 */
private parseHashLiteral(): Expression | null {
  const token = this.curToken
  const pairs = new Map<Expression, Expression>()

  // 持续解析键值对，直到遇到 }
  while (!this.peekTokenIs(RBRACE)) {
    // 移动到键
    this.nextToken()

    // 解析键表达式
    const key = this.parseExpression(Precedence.LOWEST)
    if (!key) {
      return null
    }

    // 期望冒号
    if (!this.expectPeek(COLON)) {
      return null
    }

    // 移动到值
    this.nextToken()

    // 解析值表达式
    const value = this.parseExpression(Precedence.LOWEST)
    if (!value) {
      return null
    }

    // 存储键值对
    pairs.set(key, value)

    // 如果下一个不是 }，期望是逗号
    if (!this.peekTokenIs(RBRACE) && !this.expectPeek(COMMA)) {
      return null
    }
  }

  // 期望 }
  if (!this.expectPeek(RBRACE)) {
    return null
  }

  return new HashLiteral(token, pairs)
}
```

**解析示例：**

```
输入: '{"name": "Monkey", "age": 1}'

Token 流:
[{] [STRING:name] [:] [STRING:Monkey] [,] [STRING:age] [:] [INT:1] [}]

解析过程:
1. curToken = {
2. pairs = new Map()

循环 1:
  nextToken() → curToken = STRING (name)
  key = StringLiteral("name")
  expectPeek(COLON) → curToken = :
  nextToken() → curToken = STRING (Monkey)
  value = StringLiteral("Monkey")
  pairs.set(StringLiteral("name"), StringLiteral("Monkey"))
  peekToken = COMMA
  expectPeek(COMMA) → curToken = ,

循环 2:
  nextToken() → curToken = STRING (age)
  key = StringLiteral("age")
  expectPeek(COLON) → curToken = :
  nextToken() → curToken = INT (1)
  value = IntegerLiteral(1)
  pairs.set(StringLiteral("age"), IntegerLiteral(1))
  peekToken = }

退出循环

expectPeek(RBRACE) → curToken = }
返回 HashLiteral
```

#### 可哈希对象

只有实现了 `Hashable` 接口的对象才能作为哈希表的键。

```typescript
/**
 * Hashable 接口
 *
 * 可以作为哈希键的对象必须实现此接口
 */
export interface Hashable {
  hashKey(): HashKey
}

/**
 * HashKey 类
 *
 * 哈希表内部使用的键
 */
export class HashKey {
  type: ObjectType
  value: number | string

  constructor(type: ObjectType, value: number | string) {
    this.type = type
    this.value = value
  }

  // 生成字符串形式的键（用于 Map）
  toString(): string {
    return `${this.type}:${this.value}`
  }
}
```

**实现 Hashable：**

```typescript
// IntegerObject 可哈希
export class IntegerObject implements MonkeyObject, Hashable {
  value: number

  constructor(value: number) {
    this.value = value
  }

  // ...

  hashKey(): HashKey {
    return new HashKey(INTEGER_OBJ, this.value)
  }
}

// StringObject 可哈希
export class StringObject implements MonkeyObject, Hashable {
  value: string

  constructor(value: string) {
    this.value = value
  }

  // ...

  hashKey(): HashKey {
    return new HashKey(STRING_OBJ, this.value)
  }
}

// BooleanObject 可哈希
export class BooleanObject implements MonkeyObject, Hashable {
  value: boolean

  constructor(value: boolean) {
    this.value = value
  }

  // ...

  hashKey(): HashKey {
    const value = this.value ? 1 : 0
    return new HashKey(BOOLEAN_OBJ, value)
  }
}
```

**为什么这样设计？**

```monkey
// 这两个键应该被认为是相同的
let hash1 = {5: "five"};
let hash2 = {5: "FIVE"};

// 如果直接用对象引用作为键：
IntegerObject(5) !== IntegerObject(5)  // 不同的对象实例

// 使用 hashKey 方法：
IntegerObject(5).hashKey() === IntegerObject(5).hashKey()  // true
// 因为它们返回相同的 HashKey { type: "INTEGER", value: 5 }
```

#### 求值哈希表字面量

```typescript
/**
 * 求值哈希表字面量
 */
function evalHashLiteral(node: HashLiteral, env: Environment): MonkeyObject {
  const pairs = new Map<string, HashPair>()

  // 遍历所有键值对
  for (const [keyNode, valueNode] of node.pairs) {
    // 求值键
    const key = evalNode(keyNode, env)
    if (isError(key)) {
      return key!
    }

    // 检查键是否可哈希
    if (!isHashable(key)) {
      return new ErrorObject(`unusable as hash key: ${key!.type()}`)
    }

    // 求值值
    const value = evalNode(valueNode, env)
    if (isError(value)) {
      return value!
    }

    // 生成哈希键
    const hashed = (key as Hashable).hashKey()
    const hashKeyStr = hashed.toString()

    // 存储键值对
    pairs.set(hashKeyStr, new HashPair(key!, value!))
  }

  return new HashObject(pairs)
}

/**
 * 检查对象是否可哈希
 */
function isHashable(obj: MonkeyObject | null): obj is Hashable {
  if (!obj) return false
  return 'hashKey' in obj && typeof (obj as any).hashKey === 'function'
}
```

#### 哈希表操作示例

```monkey
let person = {"name": "Monkey", "age": 1};

// 访问元素
person["name"];    // "Monkey"
person["age"];     // 1

// 嵌套访问
let data = {"user": {"name": "John", "age": 30}};
data["user"]["name"];  // "John"

// 使用数字和布尔键
let numbers = {1: "one", 2: "two"};
numbers[1];        // "one"

let flags = {true: "yes", false: "no"};
flags[true];       // "yes"
```

### 4.2.3 索引表达式

索引表达式用于访问数组元素或哈希表的值。

#### AST 表示

```typescript
/**
 * IndexExpression 类
 *
 * 表示索引访问表达式
 * 语法：<expression>[<expression>]
 */
export class IndexExpression implements Expression {
  token: Token // [ token
  left: Expression // 被索引的对象
  index: Expression // 索引值

  constructor(token: Token, left: Expression, index: Expression) {
    this.token = token
    this.left = left
    this.index = index
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return `(${this.left.toString()}[${this.index.toString()}])`
  }
}
```

#### 解析索引表达式

```typescript
/**
 * 解析索引表达式
 *
 * 这是一个中缀解析函数，left 是被索引的表达式
 */
private parseIndexExpression(left: Expression): Expression | null {
  const token = this.curToken

  // 移动到索引表达式
  this.nextToken()

  // 解析索引
  const index = this.parseExpression(Precedence.LOWEST)
  if (!index) {
    return null
  }

  // 期望 ]
  if (!this.expectPeek(RBRACKET)) {
    return null
  }

  return new IndexExpression(token, left, index)
}
```

**为什么 `[` 是中缀运算符？**

```monkey
arr[0]
^   ^
|   └── [ 是中缀运算符
└────── 左侧表达式
```

`[` 出现在表达式之后，所以它是中缀运算符。

#### 求值索引表达式

```typescript
/**
 * 求值索引表达式
 */
function evalIndexExpression(
  node: IndexExpression,
  env: Environment
): MonkeyObject {
  // 求值左侧（被索引的对象）
  const left = evalNode(node.left, env)
  if (isError(left)) {
    return left!
  }

  // 求值索引
  const index = evalNode(node.index, env)
  if (isError(index)) {
    return index!
  }

  // 根据左侧对象类型分派
  if (left instanceof ArrayObject && index instanceof IntegerObject) {
    return evalArrayIndexExpression(left, index)
  }

  if (left instanceof HashObject) {
    return evalHashIndexExpression(left, index!)
  }

  return new ErrorObject(`index operator not supported: ${left!.type()}`)
}

/**
 * 求值数组索引
 */
function evalArrayIndexExpression(
  array: ArrayObject,
  index: IntegerObject
): MonkeyObject {
  const idx = index.value
  const max = array.elements.length - 1

  // 检查索引范围
  if (idx < 0 || idx > max) {
    return NULL
  }

  return array.elements[idx]
}

/**
 * 求值哈希索引
 */
function evalHashIndexExpression(
  hash: HashObject,
  index: MonkeyObject
): MonkeyObject {
  // 检查索引是否可哈希
  if (!isHashable(index)) {
    return new ErrorObject(`unusable as hash key: ${index.type()}`)
  }

  // 生成哈希键并查找
  const hashKey = index.hashKey()
  const hashKeyStr = hashKey.toString()

  const pair = hash.pairs.get(hashKeyStr)
  if (!pair) {
    return NULL
  }

  return pair.value
}
```

**执行示例：**

```monkey
let arr = [1, 2, 3];
arr[1];
```

```
1. evalIndexExpression
   left = arr
   index = 1

2. evalNode(arr, env)
   → env.get('arr')
   → ArrayObject([1, 2, 3])

3. evalNode(1, env)
   → IntegerObject(1)

4. evalArrayIndexExpression
   idx = 1
   max = 2
   idx 在范围内
   返回 elements[1] = IntegerObject(2)
```

## 4.3 字符串操作

### 字符串拼接

```typescript
/**
 * 求值字符串中缀表达式
 */
function evalStringInfixExpression(
  operator: string,
  left: StringObject,
  right: StringObject
): MonkeyObject {
  // 只支持 + 运算符
  if (operator !== '+') {
    return new ErrorObject(
      `unknown operator: ${left.type()} ${operator} ${right.type()}`
    )
  }

  // 字符串拼接
  return new StringObject(left.value + right.value)
}
```

### 使用示例

```monkey
// 基本拼接
"Hello" + " " + "World";  // "Hello World"

// 变量拼接
let firstName = "John";
let lastName = "Doe";
let fullName = firstName + " " + lastName;  // "John Doe"

// 在哈希表中使用
let greeting = {"hello": "world"};
greeting["hel" + "lo"];  // "world"
```

## 4.4 内置函数详解

### 4.4.1 数组操作函数

#### len - 获取长度

```typescript
const lenBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  const arg = args[0]

  // 字符串长度
  if (arg instanceof StringObject) {
    return new IntegerObject(arg.value.length)
  }

  // 数组长度
  if (arg instanceof ArrayObject) {
    return new IntegerObject(arg.elements.length)
  }

  return new ErrorObject(`argument to 'len' not supported, got ${arg.type()}`)
})
```

**使用示例：**

```monkey
len("hello");        // 5
len([1, 2, 3]);      // 3
len([]);             // 0
```

#### first - 获取第一个元素

```typescript
const firstBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'first' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]

  if (arr.elements.length > 0) {
    return arr.elements[0]
  }

  return NULL
})
```

**使用示例：**

```monkey
first([1, 2, 3]);    // 1
first([]);           // null
```

#### last - 获取最后一个元素

```typescript
const lastBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'last' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  const length = arr.elements.length

  if (length > 0) {
    return arr.elements[length - 1]
  }

  return NULL
})
```

**使用示例：**

```monkey
last([1, 2, 3]);     // 3
last([]);            // null
```

#### rest - 获取除第一个外的其余元素

```typescript
const restBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'rest' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  const length = arr.elements.length

  if (length > 0) {
    // 创建新数组，不修改原数组
    const newElements = arr.elements.slice(1)
    return new ArrayObject(newElements)
  }

  return NULL
})
```

**使用示例：**

```monkey
rest([1, 2, 3]);     // [2, 3]
rest([1]);           // []
rest([]);            // null
```

**为什么返回新数组？**

遵循函数式编程的不可变性原则：

```monkey
let arr = [1, 2, 3];
let tail = rest(arr);
// arr 仍然是 [1, 2, 3]
// tail 是新数组 [2, 3]
```

#### push - 添加元素

```typescript
const pushBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 2) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=2`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'push' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]

  // 创建新数组，添加元素
  const newElements = [...arr.elements, args[1]]
  return new ArrayObject(newElements)
})
```

**使用示例：**

```monkey
let arr = [1, 2, 3];
let newArr = push(arr, 4);
// arr 仍然是 [1, 2, 3]
// newArr 是 [1, 2, 3, 4]
```

### 4.4.2 输入输出函数

#### puts - 打印输出

```typescript
const putsBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  for (const arg of args) {
    console.log(arg.inspect())
  }

  return NULL
})
```

**使用示例：**

```monkey
puts("Hello, World!");
// 输出: Hello, World!

puts(1, 2, 3);
// 输出:
// 1
// 2
// 3

puts([1, 2, 3], {"name": "Monkey"});
// 输出:
// [1, 2, 3]
// {name: Monkey}
```

## 4.5 高级特性

### 4.5.1 高阶函数

高阶函数是接受函数作为参数或返回函数的函数。

#### map - 映射函数

```monkey
let map = fn(arr, f) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      return accumulated;
    }

    let head = first(arr);
    let tail = rest(arr);

    return iter(tail, push(accumulated, f(head)));
  };

  return iter(arr, []);
};

// 使用示例
let double = fn(x) { x * 2 };
map([1, 2, 3, 4], double);
// 返回: [2, 4, 6, 8]
```

**执行过程：**

```
map([1, 2, 3], double)

iter([1, 2, 3], [])
├── head = 1, tail = [2, 3]
├── f(1) = 2
├── accumulated = [2]
└── iter([2, 3], [2])
    ├── head = 2, tail = [3]
    ├── f(2) = 4
    ├── accumulated = [2, 4]
    └── iter([3], [2, 4])
        ├── head = 3, tail = []
        ├── f(3) = 6
        ├── accumulated = [2, 4, 6]
        └── iter([], [2, 4, 6])
            └── 返回 [2, 4, 6]
```

#### reduce - 归约函数

```monkey
let reduce = fn(arr, initial, f) {
  let iter = fn(arr, result) {
    if (len(arr) == 0) {
      return result;
    }

    let head = first(arr);
    let tail = rest(arr);

    return iter(tail, f(result, head));
  };

  return iter(arr, initial);
};

// 使用示例：求和
let sum = fn(arr) {
  let add = fn(acc, x) { acc + x };
  return reduce(arr, 0, add);
};

sum([1, 2, 3, 4, 5]);  // 15
```

#### filter - 过滤函数

```monkey
let filter = fn(arr, predicate) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      return accumulated;
    }

    let head = first(arr);
    let tail = rest(arr);

    if (predicate(head)) {
      return iter(tail, push(accumulated, head));
    } else {
      return iter(tail, accumulated);
    }
  };

  return iter(arr, []);
};

// 使用示例：过滤偶数
let isEven = fn(x) { x % 2 == 0 };
filter([1, 2, 3, 4, 5], isEven);
// 返回: [2, 4]
```

**注意：** Monkey 语言目前不支持 `%` 运算符，这只是示例。

### 4.5.2 闭包应用

#### 计数器

```monkey
let newCounter = fn() {
  let count = 0;

  return fn() {
    count = count + 1;
    return count;
  };
};

let counter1 = newCounter();
counter1();  // 1
counter1();  // 2
counter1();  // 3

let counter2 = newCounter();
counter2();  // 1（独立的计数器）
```

#### 累加器工厂

```monkey
let newAdder = fn(n) {
  return fn(x) { x + n };
};

let addTwo = newAdder(2);
let addTen = newAdder(10);

addTwo(5);   // 7
addTen(5);   // 15
```

#### 私有状态

```monkey
let newPerson = fn(name, age) {
  return {
    "getName": fn() { name },
    "getAge": fn() { age },
    "setAge": fn(newAge) { age = newAge; return age; }
  };
};

let person = newPerson("Alice", 30);
person["getName"]();     // "Alice"
person["getAge"]();      // 30
person["setAge"](31);    // 31
person["getAge"]();      // 31
```

### 4.5.3 递归技巧

#### 斐波那契数列

```monkey
let fibonacci = fn(n) {
  if (n == 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
};

fibonacci(10);  // 55
```

#### 阶乘

```monkey
let factorial = fn(n) {
  if (n == 0) {
    return 1;
  }
  return n * factorial(n - 1);
};

factorial(5);  // 120
```

#### 尾递归优化版本

虽然 JavaScript 不支持尾调用优化，但我们可以写成尾递归形式：

```monkey
let factorialTail = fn(n, acc) {
  if (n == 0) {
    return acc;
  }
  return factorialTail(n - 1, n * acc);
};

let factorial = fn(n) {
  return factorialTail(n, 1);
};

factorial(5);  // 120
```

## 4.6 实战示例

### 示例 1：构建链表

```monkey
// 链表节点
let node = fn(value, next) {
  return {"value": value, "next": next};
};

// 创建链表: 1 -> 2 -> 3
let list = node(1, node(2, node(3, null)));

// 遍历链表
let printList = fn(list) {
  if (list == null) {
    return null;
  }

  puts(list["value"]);
  return printList(list["next"]);
};

printList(list);
// 输出:
// 1
// 2
// 3
```

### 示例 2：实现 fold（折叠）

```monkey
let foldLeft = fn(arr, initial, f) {
  if (len(arr) == 0) {
    return initial;
  }

  let head = first(arr);
  let tail = rest(arr);

  return foldLeft(tail, f(initial, head), f);
};

// 求和
let sum = fn(arr) {
  let add = fn(a, b) { a + b };
  return foldLeft(arr, 0, add);
};

sum([1, 2, 3, 4, 5]);  // 15

// 求积
let product = fn(arr) {
  let multiply = fn(a, b) { a * b };
  return foldLeft(arr, 1, multiply);
};

product([1, 2, 3, 4, 5]);  // 120
```

### 示例 3：快速排序

```monkey
let quicksort = fn(arr) {
  if (len(arr) <= 1) {
    return arr;
  }

  let pivot = first(arr);
  let rest = rest(arr);

  // 分区
  let partition = fn(arr, pivot, less, greater) {
    if (len(arr) == 0) {
      return {"less": less, "greater": greater};
    }

    let head = first(arr);
    let tail = rest(arr);

    if (head < pivot) {
      return partition(tail, pivot, push(less, head), greater);
    } else {
      return partition(tail, pivot, less, push(greater, head));
    }
  };

  let parts = partition(rest, pivot, [], []);
  let sortedLess = quicksort(parts["less"]);
  let sortedGreater = quicksort(parts["greater"]);

  // 合并
  let concat = fn(a, b) {
    if (len(a) == 0) {
      return b;
    }
    return concat(rest(a), push([first(a)], b));
  };

  return concat(sortedLess, push([pivot], sortedGreater));
};

quicksort([3, 1, 4, 1, 5, 9, 2, 6]);
// 返回: [1, 1, 2, 3, 4, 5, 6, 9]
```

### 示例 4：实现对象方法

```monkey
// 创建一个"类"
let newStack = fn() {
  let items = [];

  return {
    "push": fn(item) {
      items = push(items, item);
      return item;
    },
    "pop": fn() {
      if (len(items) == 0) {
        return null;
      }
      let item = last(items);
      // 注意：这里应该删除最后一个元素
      // 但 Monkey 没有内置的 removeLast 函数
      // 实际使用中可能需要自己实现
      return item;
    },
    "size": fn() {
      return len(items);
    },
    "isEmpty": fn() {
      return len(items) == 0;
    }
  };
};

let stack = newStack();
stack["push"](1);
stack["push"](2);
stack["push"](3);
stack["size"]();      // 3
stack["isEmpty"]();   // false
```

## 4.7 可能的扩展方向

### 语言特性扩展

#### 1. 循环结构

```monkey
// while 循环
while (x < 10) {
  x = x + 1;
}

// for 循环
for (let i = 0; i < 10; i = i + 1) {
  puts(i);
}
```

#### 2. 赋值表达式

```monkey
// 重新赋值变量
let x = 5;
x = 10;  // 目前不支持
```

#### 3. 更多运算符

```monkey
// 取模
5 % 2;  // 1

// 指数
2 ** 3;  // 8

// 逻辑运算符
true && false;  // false
true || false;  // true
```

#### 4. 解构

```monkey
// 数组解构
let [a, b, c] = [1, 2, 3];

// 对象解构
let {name, age} = {"name": "Monkey", "age": 1};
```

#### 5. 展开运算符

```monkey
// 数组展开
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5];  // [1, 2, 3, 4, 5]

// 对象展开
let obj1 = {"a": 1, "b": 2};
let obj2 = {...obj1, "c": 3};  // {"a": 1, "b": 2, "c": 3}
```

### 内置函数扩展

#### 字符串操作

```typescript
// split
split('hello world', ' ') // ["hello", "world"]

// join
join(['hello', 'world'], ' ') // "hello world"

// substr
substr('hello', 0, 2) // "he"
```

#### 数组操作

```typescript
// slice
slice([1, 2, 3, 4, 5], 1, 3) // [2, 3]

// concat
concat([1, 2], [3, 4]) // [1, 2, 3, 4]

// reverse
reverse([1, 2, 3]) // [3, 2, 1]
```

#### 对象操作

```typescript
// keys
keys({ a: 1, b: 2 }) // ["a", "b"]

// values
values({ a: 1, b: 2 }) // [1, 2]

// hasKey
hasKey({ a: 1 }, 'a') // true
```

### 标准库

可以用 Monkey 本身实现标准库：

```monkey
// math.monkey
let abs = fn(x) {
  if (x < 0) {
    return -x;
  }
  return x;
};

let max = fn(a, b) {
  if (a > b) { return a; }
  return b;
};

let min = fn(a, b) {
  if (a < b) { return a; }
  return b;
};

// list.monkey
let map = fn(arr, f) { /* ... */ };
let filter = fn(arr, pred) { /* ... */ };
let reduce = fn(arr, init, f) { /* ... */ };
```

## 小结

在本章中，我们扩展了 Monkey 解释器的功能：

### 新增数据结构

- **数组**：有序集合，支持索引访问
- **哈希表**：键值对映射，支持任意可哈希类型作为键
- **索引表达式**：统一的语法访问数组和哈希表

### 新增内置函数

- **len**：获取字符串或数组长度
- **first/last**：获取数组的第一个/最后一个元素
- **rest**：获取数组除第一个元素外的其余元素
- **push**：向数组末尾添加元素
- **puts**：打印输出

### 高级编程技术

- **高阶函数**：map、reduce、filter
- **闭包应用**：计数器、累加器、私有状态
- **递归模式**：斐波那契、阶乘、快速排序

### 设计原则

- **不可变性**：内置函数返回新对象而不修改原对象
- **函数式风格**：鼓励使用高阶函数和递归
- **灵活性**：哈希表键可以是整数、字符串或布尔值

Monkey 语言虽然简单，但已经足够强大，可以实现复杂的算法和数据结构。这证明了一个好的语言设计只需要少数几个核心特性，其余功能可以通过组合实现。

---

**上一章**：[第三章：求值](./03-求值.md)

**附录**：[快速参考](./appendix.md)

**源代码参考**：

- [ast.ts](../src/monkey/ast/ast.ts) - 数组和哈希表的 AST 节点
- [parser.ts](../src/monkey/parser/parser.ts) - 解析数组和哈希表
- [object.ts](../src/monkey/object/object.ts) - 运行时对象
- [evaluator.ts](../src/monkey/evaluator/evaluator.ts) - 求值器
- [builtins.ts](../src/monkey/evaluator/builtins.ts) - 内置函数

**推荐阅读**：

- [Little Schemer](https://mitpress.mit.edu/books/little-schemer) - 学习递归思维
- [SICP](https://mitpress.mit.edu/sites/default/files/sicp/index.html) - 程序的构造和解释
