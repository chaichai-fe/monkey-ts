# 第四章：扩展解释器

## 目录

- [4.1 扩展简介](#41-扩展简介)
- [4.2 字符串](#42-字符串)
- [4.3 数组](#43-数组)
- [4.4 哈希表](#44-哈希表)
- [4.5 索引表达式](#45-索引表达式)
- [4.6 内置函数扩展](#46-内置函数扩展)
- [4.7 完整示例](#47-完整示例)

## 4.1 扩展简介

在前面的章节中，我们已经构建了一个功能完整的解释器。现在让我们扩展它以支持更多的数据类型和操作。

### 要添加的特性

1. **字符串**：支持字符串字面量和字符串操作
2. **数组**：支持数组字面量和数组操作
3. **哈希表**：支持键值对存储
4. **索引表达式**：支持 `array[index]` 和 `hash[key]` 语法

### 扩展的步骤

对于每种新特性，我们需要：

1. **更新 Lexer**：添加新的词法单元类型（如果需要）
2. **更新 AST**：添加新的 AST 节点类型
3. **更新 Parser**：添加解析逻辑
4. **更新对象系统**：添加新的对象类型
5. **更新 Evaluator**：添加求值逻辑

## 4.2 字符串

### 字符串字面量

字符串由双引号包围：

```monkey
let name = "Monkey";
let greeting = "Hello, " + name + "!";
```

### Lexer 支持

```typescript
case '"':
  tok = {
    Type: STRING,
    Literal: this.readString(),
  };
  break;

private readString(): string {
  const startPosition = this.position + 1;
  while (true) {
    this.readChar();
    if (this.ch === '"' || this.ch === "") {
      break;
    }
  }
  return this.input.slice(startPosition, this.position);
}
```

### AST 节点

```typescript
export class StringLiteral implements Expression {
  token: Token
  value: string

  constructor(token: Token, value: string) {
    this.token = token
    this.value = value
  }
}
```

### 对象类型

```typescript
export class StringObject implements MonkeyObject {
  constructor(public value: string) {}

  type(): ObjectType {
    return STRING_OBJ
  }

  inspect(): string {
    return this.value
  }
}
```

### 字符串连接

支持使用 `+` 运算符连接字符串：

```typescript
function evalStringInfixExpression(
  operator: string,
  left: MonkeyObject,
  right: MonkeyObject
): MonkeyObject {
  if (operator !== '+') {
    return newError(
      `unknown operator: ${left.type()} ${operator} ${right.type()}`
    )
  }

  const leftVal = (left as StringObject).value
  const rightVal = (right as StringObject).value
  return new StringObject(leftVal + rightVal)
}
```

## 4.3 数组

### 数组字面量

```monkey
let myArray = [1, 2, 3, 4];
let mixed = [1, "hello", true, fn(x) { x * 2 }];
```

### AST 节点

```typescript
export class ArrayLiteral implements Expression {
  token: Token
  elements: Expression[] = []

  constructor(token: Token) {
    this.token = token
  }
}
```

### Parser 支持

```typescript
private parseArrayLiteral(): Expression | null {
  const array = new ArrayLiteral(this.curToken);
  const elements = this.parseExpressionList(RBRACKET);
  if (elements === null) {
    return null;
  }
  array.elements = elements;
  return array;
}
```

### 对象类型

```typescript
export class ArrayObject implements MonkeyObject {
  constructor(public elements: MonkeyObject[]) {}

  type(): ObjectType {
    return ARRAY_OBJ
  }

  inspect(): string {
    const elements = this.elements.map((e) => e.inspect()).join(', ')
    return `[${elements}]`
  }
}
```

### 求值器支持

```typescript
if (node instanceof ArrayLiteral) {
  const elements = evalExpressions(node.elements, env)
  if (elements.length === 1 && isError(elements[0])) {
    return elements[0]
  }
  return new ArrayObject(elements)
}
```

## 4.4 哈希表

哈希表（字典）存储键值对：

```monkey
let person = {
  "name": "John",
  "age": 30,
  "active": true
};
```

### 哈希键

为了高效存储和查找，我们为可哈希的对象实现哈希函数：

```typescript
export class HashKey {
  constructor(public type: ObjectType, public value: number) {}

  toString(): string {
    return `${this.type}:${this.value}`
  }
}

export interface Hashable {
  hashKey(): HashKey
}
```

### 可哈希的类型

- `IntegerObject`
- `BooleanObject`
- `StringObject`

### 对象类型

```typescript
export class HashPair {
  constructor(public key: MonkeyObject, public value: MonkeyObject) {}
}

export class HashObject implements MonkeyObject {
  public pairs: Map<string, HashPair>

  constructor() {
    this.pairs = new Map()
  }

  type(): ObjectType {
    return HASH_OBJ
  }
}
```

### 求值器支持

```typescript
function evalHashLiteral(node: HashLiteral, env: Environment): MonkeyObject {
  const hash = new HashObject()

  for (const [keyNode, valueNode] of node.pairs) {
    const key = evalNode(keyNode, env)
    if (isError(key)) return key!

    if (!isHashable(key!)) {
      return newError(`unusable as hash key: ${key!.type()}`)
    }

    const value = evalNode(valueNode, env)
    if (isError(value)) return value!

    const hashed = key!.hashKey()
    hash.pairs.set(hashed.toString(), new HashPair(key!, value!))
  }

  return hash
}
```

## 4.5 索引表达式

索引表达式允许我们访问数组元素和哈希表值：

```monkey
// 数组索引
arr[0];

// 哈希表访问
person["name"];

// 嵌套索引
matrix[0][1];
users[0]["name"];
```

### AST 节点

```typescript
export class IndexExpression implements Expression {
  token: Token
  left: Expression
  index: Expression

  constructor(token: Token, left: Expression, index: Expression) {
    this.token = token
    this.left = left
    this.index = index
  }
}
```

### 求值器支持

```typescript
function evalIndexExpression(
  left: MonkeyObject,
  index: MonkeyObject
): MonkeyObject {
  // 数组索引
  if (left.type() === ARRAY_OBJ && index.type() === INTEGER_OBJ) {
    return evalArrayIndexExpression(left, index)
  }

  // 哈希表访问
  if (left.type() === HASH_OBJ) {
    return evalHashIndexExpression(left, index)
  }

  return newError(`index operator not supported: ${left.type()}`)
}
```

## 4.6 内置函数扩展

### 数组操作函数

```monkey
len([1, 2, 3]);    // 3
first([1, 2, 3]);  // 1
last([1, 2, 3]);   // 3
rest([1, 2, 3]);   // [2, 3]
push([1, 2], 3);   // [1, 2, 3]
```

### 函数式编程示例

```monkey
// map: 将函数应用到数组的每个元素
let map = fn(arr, f) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      accumulated
    } else {
      iter(rest(arr), push(accumulated, f(first(arr))))
    }
  };
  iter(arr, []);
};

let double = fn(x) { x * 2 };
map([1, 2, 3, 4], double);  // [2, 4, 6, 8]

// reduce: 将数组归约为单个值
let reduce = fn(arr, initial, f) {
  let iter = fn(arr, result) {
    if (len(arr) == 0) {
      result
    } else {
      iter(rest(arr), f(result, first(arr)))
    }
  };
  iter(arr, initial);
};

let sum = fn(a, b) { a + b };
reduce([1, 2, 3, 4], 0, sum);  // 10
```

## 4.7 完整示例

### 示例 1：数据处理

```monkey
let data = [
  {"name": "Alice", "score": 85},
  {"name": "Bob", "score": 92},
  {"name": "Charlie", "score": 78}
];

// 计算平均分
let scores = map(data, fn(student) { student["score"] });
let total = reduce(scores, 0, fn(a, b) { a + b });
let average = total / len(scores);
puts(average);  // 85
```

### 示例 2：嵌套数据结构

```monkey
let company = {
  "name": "Tech Corp",
  "departments": [
    {
      "name": "Engineering",
      "employees": [
        {"name": "Alice", "role": "Developer"}
      ]
    }
  ]
};

let engDept = first(company["departments"]);
let firstEng = first(engDept["employees"]);
puts(firstEng["name"]);  // "Alice"
```

## 小结

在本章中，我们扩展了解释器以支持：

1. **字符串**：字符串字面量、字符串连接
2. **数组**：数组字面量、数组索引、数组操作函数
3. **哈希表**：哈希表字面量、键值对存储、哈希表访问
4. **索引表达式**：数组索引、哈希表访问、嵌套索引
5. **函数式编程**：高阶函数、使用内置函数实现 map、reduce

### 进一步的扩展

你可以继续扩展解释器，添加更多特性：

- 浮点数支持
- 注释支持
- for 循环
- 模块系统
- 更多的内置函数

---

**上一章**：[第三章：求值](./03-evaluation.md)

**返回目录**：[README](./README.md)

**源代码参考**：

- [ast.ts](../src/monkey/ast/ast.ts)
- [parser.ts](../src/monkey/parser/parser.ts)
- [object.ts](../src/monkey/object/object.ts)
- [evaluator.ts](../src/monkey/evaluator/evaluator.ts)

---

**恭喜！** 🎉 你已经完成了 Monkey 语言解释器的学习之旅！
