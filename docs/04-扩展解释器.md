# ç¬¬å››ç« ï¼šæ‰©å±•è§£é‡Šå™¨

## ç›®å½•

- [4.1 æ‰©å±•ç®€ä»‹](#41-æ‰©å±•ç®€ä»‹)
- [4.2 å­—ç¬¦ä¸²](#42-å­—ç¬¦ä¸²)
- [4.3 æ•°ç»„](#43-æ•°ç»„)
- [4.4 å“ˆå¸Œè¡¨](#44-å“ˆå¸Œè¡¨)
- [4.5 ç´¢å¼•è¡¨è¾¾å¼](#45-ç´¢å¼•è¡¨è¾¾å¼)
- [4.6 å†…ç½®å‡½æ•°æ‰©å±•](#46-å†…ç½®å‡½æ•°æ‰©å±•)
- [4.7 å®Œæ•´ç¤ºä¾‹](#47-å®Œæ•´ç¤ºä¾‹)

## 4.1 æ‰©å±•ç®€ä»‹

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å·²ç»æ„å»ºäº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„è§£é‡Šå™¨ã€‚ç°åœ¨è®©æˆ‘ä»¬æ‰©å±•å®ƒä»¥æ”¯æŒæ›´å¤šçš„æ•°æ®ç±»å‹å’Œæ“ä½œã€‚

### è¦æ·»åŠ çš„ç‰¹æ€§

1. **å­—ç¬¦ä¸²**ï¼šæ”¯æŒå­—ç¬¦ä¸²å­—é¢é‡å’Œå­—ç¬¦ä¸²æ“ä½œ
2. **æ•°ç»„**ï¼šæ”¯æŒæ•°ç»„å­—é¢é‡å’Œæ•°ç»„æ“ä½œ
3. **å“ˆå¸Œè¡¨**ï¼šæ”¯æŒé”®å€¼å¯¹å­˜å‚¨
4. **ç´¢å¼•è¡¨è¾¾å¼**ï¼šæ”¯æŒ `array[index]` å’Œ `hash[key]` è¯­æ³•

### æ‰©å±•çš„æ­¥éª¤

å¯¹äºæ¯ç§æ–°ç‰¹æ€§ï¼Œæˆ‘ä»¬éœ€è¦ï¼š

1. **æ›´æ–° Lexer**ï¼šæ·»åŠ æ–°çš„è¯æ³•å•å…ƒç±»å‹ï¼ˆå¦‚æœéœ€è¦ï¼‰
2. **æ›´æ–° AST**ï¼šæ·»åŠ æ–°çš„ AST èŠ‚ç‚¹ç±»å‹
3. **æ›´æ–° Parser**ï¼šæ·»åŠ è§£æé€»è¾‘
4. **æ›´æ–°å¯¹è±¡ç³»ç»Ÿ**ï¼šæ·»åŠ æ–°çš„å¯¹è±¡ç±»å‹
5. **æ›´æ–° Evaluator**ï¼šæ·»åŠ æ±‚å€¼é€»è¾‘

## 4.2 å­—ç¬¦ä¸²

### å­—ç¬¦ä¸²å­—é¢é‡

å­—ç¬¦ä¸²ç”±åŒå¼•å·åŒ…å›´ï¼š

```monkey
let name = "Monkey";
let greeting = "Hello, " + name + "!";
```

### Lexer æ”¯æŒ

```typescript
case '"':
  tok = {
    Type: STRING,
    Literal: this.readString(),
  };
  break;

private readString(): string {
  const startPosition = this.position + 1;
  while (true) {
    this.readChar();
    if (this.ch === '"' || this.ch === "") {
      break;
    }
  }
  return this.input.slice(startPosition, this.position);
}
```

### AST èŠ‚ç‚¹

```typescript
export class StringLiteral implements Expression {
  token: Token
  value: string

  constructor(token: Token, value: string) {
    this.token = token
    this.value = value
  }
}
```

### å¯¹è±¡ç±»å‹

```typescript
export class StringObject implements MonkeyObject {
  constructor(public value: string) {}

  type(): ObjectType {
    return STRING_OBJ
  }

  inspect(): string {
    return this.value
  }
}
```

### å­—ç¬¦ä¸²è¿æ¥

æ”¯æŒä½¿ç”¨ `+` è¿ç®—ç¬¦è¿æ¥å­—ç¬¦ä¸²ï¼š

```typescript
function evalStringInfixExpression(
  operator: string,
  left: MonkeyObject,
  right: MonkeyObject
): MonkeyObject {
  if (operator !== '+') {
    return newError(
      `unknown operator: ${left.type()} ${operator} ${right.type()}`
    )
  }

  const leftVal = (left as StringObject).value
  const rightVal = (right as StringObject).value
  return new StringObject(leftVal + rightVal)
}
```

## 4.3 æ•°ç»„

### æ•°ç»„å­—é¢é‡

```monkey
let myArray = [1, 2, 3, 4];
let mixed = [1, "hello", true, fn(x) { x * 2 }];
```

### AST èŠ‚ç‚¹

```typescript
export class ArrayLiteral implements Expression {
  token: Token
  elements: Expression[] = []

  constructor(token: Token) {
    this.token = token
  }
}
```

### Parser æ”¯æŒ

```typescript
private parseArrayLiteral(): Expression | null {
  const array = new ArrayLiteral(this.curToken);
  const elements = this.parseExpressionList(RBRACKET);
  if (elements === null) {
    return null;
  }
  array.elements = elements;
  return array;
}
```

### å¯¹è±¡ç±»å‹

```typescript
export class ArrayObject implements MonkeyObject {
  constructor(public elements: MonkeyObject[]) {}

  type(): ObjectType {
    return ARRAY_OBJ
  }

  inspect(): string {
    const elements = this.elements.map((e) => e.inspect()).join(', ')
    return `[${elements}]`
  }
}
```

### æ±‚å€¼å™¨æ”¯æŒ

```typescript
if (node instanceof ArrayLiteral) {
  const elements = evalExpressions(node.elements, env)
  if (elements.length === 1 && isError(elements[0])) {
    return elements[0]
  }
  return new ArrayObject(elements)
}
```

## 4.4 å“ˆå¸Œè¡¨

å“ˆå¸Œè¡¨ï¼ˆå­—å…¸ï¼‰å­˜å‚¨é”®å€¼å¯¹ï¼š

```monkey
let person = {
  "name": "John",
  "age": 30,
  "active": true
};
```

### å“ˆå¸Œé”®

ä¸ºäº†é«˜æ•ˆå­˜å‚¨å’ŒæŸ¥æ‰¾ï¼Œæˆ‘ä»¬ä¸ºå¯å“ˆå¸Œçš„å¯¹è±¡å®ç°å“ˆå¸Œå‡½æ•°ï¼š

```typescript
export class HashKey {
  constructor(public type: ObjectType, public value: number) {}

  toString(): string {
    return `${this.type}:${this.value}`
  }
}

export interface Hashable {
  hashKey(): HashKey
}
```

### å¯å“ˆå¸Œçš„ç±»å‹

- `IntegerObject`
- `BooleanObject`
- `StringObject`

### å¯¹è±¡ç±»å‹

```typescript
export class HashPair {
  constructor(public key: MonkeyObject, public value: MonkeyObject) {}
}

export class HashObject implements MonkeyObject {
  public pairs: Map<string, HashPair>

  constructor() {
    this.pairs = new Map()
  }

  type(): ObjectType {
    return HASH_OBJ
  }
}
```

### æ±‚å€¼å™¨æ”¯æŒ

```typescript
function evalHashLiteral(node: HashLiteral, env: Environment): MonkeyObject {
  const hash = new HashObject()

  for (const [keyNode, valueNode] of node.pairs) {
    const key = evalNode(keyNode, env)
    if (isError(key)) return key!

    if (!isHashable(key!)) {
      return newError(`unusable as hash key: ${key!.type()}`)
    }

    const value = evalNode(valueNode, env)
    if (isError(value)) return value!

    const hashed = key!.hashKey()
    hash.pairs.set(hashed.toString(), new HashPair(key!, value!))
  }

  return hash
}
```

## 4.5 ç´¢å¼•è¡¨è¾¾å¼

ç´¢å¼•è¡¨è¾¾å¼å…è®¸æˆ‘ä»¬è®¿é—®æ•°ç»„å…ƒç´ å’Œå“ˆå¸Œè¡¨å€¼ï¼š

```monkey
// æ•°ç»„ç´¢å¼•
arr[0];

// å“ˆå¸Œè¡¨è®¿é—®
person["name"];

// åµŒå¥—ç´¢å¼•
matrix[0][1];
users[0]["name"];
```

### AST èŠ‚ç‚¹

```typescript
export class IndexExpression implements Expression {
  token: Token
  left: Expression
  index: Expression

  constructor(token: Token, left: Expression, index: Expression) {
    this.token = token
    this.left = left
    this.index = index
  }
}
```

### æ±‚å€¼å™¨æ”¯æŒ

```typescript
function evalIndexExpression(
  left: MonkeyObject,
  index: MonkeyObject
): MonkeyObject {
  // æ•°ç»„ç´¢å¼•
  if (left.type() === ARRAY_OBJ && index.type() === INTEGER_OBJ) {
    return evalArrayIndexExpression(left, index)
  }

  // å“ˆå¸Œè¡¨è®¿é—®
  if (left.type() === HASH_OBJ) {
    return evalHashIndexExpression(left, index)
  }

  return newError(`index operator not supported: ${left.type()}`)
}
```

## 4.6 å†…ç½®å‡½æ•°æ‰©å±•

### æ•°ç»„æ“ä½œå‡½æ•°

```monkey
len([1, 2, 3]);    // 3
first([1, 2, 3]);  // 1
last([1, 2, 3]);   // 3
rest([1, 2, 3]);   // [2, 3]
push([1, 2], 3);   // [1, 2, 3]
```

### å‡½æ•°å¼ç¼–ç¨‹ç¤ºä¾‹

```monkey
// map: å°†å‡½æ•°åº”ç”¨åˆ°æ•°ç»„çš„æ¯ä¸ªå…ƒç´ 
let map = fn(arr, f) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      accumulated
    } else {
      iter(rest(arr), push(accumulated, f(first(arr))))
    }
  };
  iter(arr, []);
};

let double = fn(x) { x * 2 };
map([1, 2, 3, 4], double);  // [2, 4, 6, 8]

// reduce: å°†æ•°ç»„å½’çº¦ä¸ºå•ä¸ªå€¼
let reduce = fn(arr, initial, f) {
  let iter = fn(arr, result) {
    if (len(arr) == 0) {
      result
    } else {
      iter(rest(arr), f(result, first(arr)))
    }
  };
  iter(arr, initial);
};

let sum = fn(a, b) { a + b };
reduce([1, 2, 3, 4], 0, sum);  // 10
```

## 4.7 å®Œæ•´ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šæ•°æ®å¤„ç†

```monkey
let data = [
  {"name": "Alice", "score": 85},
  {"name": "Bob", "score": 92},
  {"name": "Charlie", "score": 78}
];

// è®¡ç®—å¹³å‡åˆ†
let scores = map(data, fn(student) { student["score"] });
let total = reduce(scores, 0, fn(a, b) { a + b });
let average = total / len(scores);
puts(average);  // 85
```

### ç¤ºä¾‹ 2ï¼šåµŒå¥—æ•°æ®ç»“æ„

```monkey
let company = {
  "name": "Tech Corp",
  "departments": [
    {
      "name": "Engineering",
      "employees": [
        {"name": "Alice", "role": "Developer"}
      ]
    }
  ]
};

let engDept = first(company["departments"]);
let firstEng = first(engDept["employees"]);
puts(firstEng["name"]);  // "Alice"
```

## å°ç»“

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬æ‰©å±•äº†è§£é‡Šå™¨ä»¥æ”¯æŒï¼š

1. **å­—ç¬¦ä¸²**ï¼šå­—ç¬¦ä¸²å­—é¢é‡ã€å­—ç¬¦ä¸²è¿æ¥
2. **æ•°ç»„**ï¼šæ•°ç»„å­—é¢é‡ã€æ•°ç»„ç´¢å¼•ã€æ•°ç»„æ“ä½œå‡½æ•°
3. **å“ˆå¸Œè¡¨**ï¼šå“ˆå¸Œè¡¨å­—é¢é‡ã€é”®å€¼å¯¹å­˜å‚¨ã€å“ˆå¸Œè¡¨è®¿é—®
4. **ç´¢å¼•è¡¨è¾¾å¼**ï¼šæ•°ç»„ç´¢å¼•ã€å“ˆå¸Œè¡¨è®¿é—®ã€åµŒå¥—ç´¢å¼•
5. **å‡½æ•°å¼ç¼–ç¨‹**ï¼šé«˜é˜¶å‡½æ•°ã€ä½¿ç”¨å†…ç½®å‡½æ•°å®ç° mapã€reduce

### è¿›ä¸€æ­¥çš„æ‰©å±•

ä½ å¯ä»¥ç»§ç»­æ‰©å±•è§£é‡Šå™¨ï¼Œæ·»åŠ æ›´å¤šç‰¹æ€§ï¼š

- æµ®ç‚¹æ•°æ”¯æŒ
- æ³¨é‡Šæ”¯æŒ
- for å¾ªç¯
- æ¨¡å—ç³»ç»Ÿ
- æ›´å¤šçš„å†…ç½®å‡½æ•°

---

**ä¸Šä¸€ç« **ï¼š[ç¬¬ä¸‰ç« ï¼šæ±‚å€¼](./03-evaluation.md)

**è¿”å›ç›®å½•**ï¼š[README](./README.md)

**æºä»£ç å‚è€ƒ**ï¼š

- [ast.ts](../src/monkey/ast/ast.ts)
- [parser.ts](../src/monkey/parser/parser.ts)
- [object.ts](../src/monkey/object/object.ts)
- [evaluator.ts](../src/monkey/evaluator/evaluator.ts)

---

**æ­å–œï¼** ğŸ‰ ä½ å·²ç»å®Œæˆäº† Monkey è¯­è¨€è§£é‡Šå™¨çš„å­¦ä¹ ä¹‹æ—…ï¼
