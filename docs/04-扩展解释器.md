# ç¬¬å››ç« ï¼šæ‰©å±•è§£é‡Šå™¨

> "è¯­è¨€çš„åŠ›é‡æ¥è‡ªäºå®ƒçš„å¯ç»„åˆæ€§ã€‚" â€”â€” Structure and Interpretation of Computer Programs

## ç›®å½•

- [4.1 æ‰©å±•æ¦‚è§ˆ](#41-æ‰©å±•æ¦‚è§ˆ)
- [4.2 æ•°æ®ç»“æ„](#42-æ•°æ®ç»“æ„)
  - [4.2.1 æ•°ç»„ï¼ˆArraysï¼‰](#421-æ•°ç»„arrays)
  - [4.2.2 å“ˆå¸Œè¡¨ï¼ˆHash Mapsï¼‰](#422-å“ˆå¸Œè¡¨hash-maps)
  - [4.2.3 ç´¢å¼•è¡¨è¾¾å¼](#423-ç´¢å¼•è¡¨è¾¾å¼)
- [4.3 å­—ç¬¦ä¸²æ“ä½œ](#43-å­—ç¬¦ä¸²æ“ä½œ)
- [4.4 å†…ç½®å‡½æ•°è¯¦è§£](#44-å†…ç½®å‡½æ•°è¯¦è§£)
  - [4.4.1 æ•°ç»„æ“ä½œå‡½æ•°](#441-æ•°ç»„æ“ä½œå‡½æ•°)
  - [4.4.2 è¾“å…¥è¾“å‡ºå‡½æ•°](#442-è¾“å…¥è¾“å‡ºå‡½æ•°)
- [4.5 é«˜çº§ç‰¹æ€§](#45-é«˜çº§ç‰¹æ€§)
  - [4.5.1 é«˜é˜¶å‡½æ•°](#451-é«˜é˜¶å‡½æ•°)
  - [4.5.2 é—­åŒ…åº”ç”¨](#452-é—­åŒ…åº”ç”¨)
  - [4.5.3 é€’å½’æŠ€å·§](#453-é€’å½’æŠ€å·§)
- [4.6 å®æˆ˜ç¤ºä¾‹](#46-å®æˆ˜ç¤ºä¾‹)
- [4.7 å¯èƒ½çš„æ‰©å±•æ–¹å‘](#47-å¯èƒ½çš„æ‰©å±•æ–¹å‘)

---

## 4.1 æ‰©å±•æ¦‚è§ˆ

åœ¨å‰ä¸‰ç« ä¸­ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªåŸºç¡€çš„ Monkey è§£é‡Šå™¨ã€‚ç°åœ¨è®©æˆ‘ä»¬æ‰©å±•å®ƒçš„åŠŸèƒ½ï¼Œæ·»åŠ æ›´å¼ºå¤§çš„æ•°æ®ç»“æ„å’Œæ“ä½œã€‚

### å·²å®ç°çš„æ ¸å¿ƒåŠŸèƒ½

âœ… åŸºæœ¬æ•°æ®ç±»å‹ï¼šæ•´æ•°ã€å¸ƒå°”å€¼ã€å­—ç¬¦ä¸²
âœ… å˜é‡ç»‘å®šï¼šlet è¯­å¥
âœ… å‡½æ•°ï¼šfn å…³é”®å­—ã€å‡½æ•°è°ƒç”¨ã€é—­åŒ…
âœ… è¿ç®—ç¬¦ï¼šç®—æœ¯ã€æ¯”è¾ƒã€é€»è¾‘
âœ… æ§åˆ¶æµï¼šif-else è¡¨è¾¾å¼
âœ… è¿”å›è¯­å¥

### æœ¬ç« æ–°å¢åŠŸèƒ½

ğŸ†• **æ•°ç»„**ï¼šæœ‰åºé›†åˆ `[1, 2, 3]`
ğŸ†• **å“ˆå¸Œè¡¨**ï¼šé”®å€¼å¯¹æ˜ å°„ `{"name": "Monkey"}`
ğŸ†• **ç´¢å¼•è®¿é—®**ï¼š`arr[0]`, `hash["key"]`
ğŸ†• **å­—ç¬¦ä¸²æ‹¼æ¥**ï¼š`"hello" + " world"`
ğŸ†• **å†…ç½®å‡½æ•°**ï¼š`len`, `first`, `last`, `rest`, `push`, `puts`

## 4.2 æ•°æ®ç»“æ„

### 4.2.1 æ•°ç»„ï¼ˆArraysï¼‰

#### æ•°ç»„çš„è¯­æ³•

```monkey
// å­—é¢é‡åˆ›å»º
let myArray = [1, 2, 3, 4, 5];

// æ··åˆç±»å‹
let mixed = [1, "hello", true, fn(x) { x }];

// åµŒå¥—æ•°ç»„
let matrix = [[1, 2], [3, 4], [5, 6]];

// ç©ºæ•°ç»„
let empty = [];
```

#### AST è¡¨ç¤º

```typescript
/**
 * ArrayLiteral ç±»
 *
 * è¡¨ç¤ºæ•°ç»„å­—é¢é‡
 * è¯­æ³•ï¼š[<expression>, <expression>, ...]
 */
export class ArrayLiteral implements Expression {
  token: Token // [ token
  elements: Expression[] // å…ƒç´ è¡¨è¾¾å¼åˆ—è¡¨

  constructor(token: Token, elements: Expression[]) {
    this.token = token
    this.elements = elements
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    const elements = this.elements.map((el) => el.toString()).join(', ')
    return `[${elements}]`
  }
}
```

#### è§£ææ•°ç»„å­—é¢é‡

```typescript
/**
 * è§£ææ•°ç»„å­—é¢é‡
 *
 * å½“å‰ Token æ˜¯ [
 */
private parseArrayLiteral(): Expression | null {
  const token = this.curToken

  // è§£æå…ƒç´ åˆ—è¡¨ï¼ˆä½¿ç”¨é€šç”¨çš„è¡¨è¾¾å¼åˆ—è¡¨è§£æå‡½æ•°ï¼‰
  const elements = this.parseExpressionList(RBRACKET)
  if (elements === null) {
    return null
  }

  return new ArrayLiteral(token, elements)
}
```

#### æ±‚å€¼æ•°ç»„å­—é¢é‡

```typescript
/**
 * æ±‚å€¼æ•°ç»„å­—é¢é‡
 */
function evalArrayLiteral(node: ArrayLiteral, env: Environment): MonkeyObject {
  // ä¾æ¬¡æ±‚å€¼æ‰€æœ‰å…ƒç´ 
  const elements = evalExpressions(node.elements, env)

  // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
  if (elements.length === 1 && isError(elements[0])) {
    return elements[0]
  }

  // åˆ›å»ºæ•°ç»„å¯¹è±¡
  return new ArrayObject(elements)
}
```

#### æ•°ç»„çš„è¿è¡Œæ—¶è¡¨ç¤º

```typescript
/**
 * ArrayObject ç±»
 *
 * è¡¨ç¤ºè¿è¡Œæ—¶çš„æ•°ç»„å¯¹è±¡
 */
export class ArrayObject implements MonkeyObject {
  elements: MonkeyObject[]

  constructor(elements: MonkeyObject[]) {
    this.elements = elements
  }

  type(): ObjectType {
    return ARRAY_OBJ
  }

  inspect(): string {
    const elements = this.elements.map((e) => e.inspect()).join(', ')
    return `[${elements}]`
  }
}
```

#### æ•°ç»„æ“ä½œç¤ºä¾‹

```monkey
let arr = [1, 2, 3];

// è®¿é—®å…ƒç´ 
arr[0];        // 1
arr[1];        // 2
arr[2];        // 3

// è·å–é•¿åº¦
len(arr);      // 3

// ç¬¬ä¸€ä¸ªå…ƒç´ 
first(arr);    // 1

// æœ€åä¸€ä¸ªå…ƒç´ 
last(arr);     // 3

// å»æ‰ç¬¬ä¸€ä¸ªå…ƒç´ 
rest(arr);     // [2, 3]

// æ·»åŠ å…ƒç´ ï¼ˆè¿”å›æ–°æ•°ç»„ï¼‰
push(arr, 4);  // [1, 2, 3, 4]
```

### 4.2.2 å“ˆå¸Œè¡¨ï¼ˆHash Mapsï¼‰

#### å“ˆå¸Œè¡¨çš„è¯­æ³•

```monkey
// å­—é¢é‡åˆ›å»º
let myHash = {"name": "Monkey", "age": 1};

// æ•°å­—é”®
let numberKeys = {1: "one", 2: "two", 3: "three"};

// å¸ƒå°”é”®
let boolKeys = {true: "yes", false: "no"};

// æ··åˆå€¼ç±»å‹
let mixed = {
  "name": "Monkey",
  "age": 1,
  "hobbies": ["programming", "bananas"]
};

// ç©ºå“ˆå¸Œè¡¨
let empty = {};
```

#### AST è¡¨ç¤º

```typescript
/**
 * HashLiteral ç±»
 *
 * è¡¨ç¤ºå“ˆå¸Œè¡¨å­—é¢é‡
 * è¯­æ³•ï¼š{<expression>: <expression>, ...}
 */
export class HashLiteral implements Expression {
  token: Token // { token
  pairs: Map<Expression, Expression> // é”®å€¼å¯¹æ˜ å°„

  constructor(token: Token, pairs: Map<Expression, Expression>) {
    this.token = token
    this.pairs = pairs
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    const pairs: string[] = []
    for (const [key, value] of this.pairs) {
      pairs.push(`${key.toString()}:${value.toString()}`)
    }
    return `{${pairs.join(', ')}}`
  }
}
```

#### è§£æå“ˆå¸Œè¡¨å­—é¢é‡

```typescript
/**
 * è§£æå“ˆå¸Œè¡¨å­—é¢é‡
 *
 * å½“å‰ Token æ˜¯ {
 */
private parseHashLiteral(): Expression | null {
  const token = this.curToken
  const pairs = new Map<Expression, Expression>()

  // æŒç»­è§£æé”®å€¼å¯¹ï¼Œç›´åˆ°é‡åˆ° }
  while (!this.peekTokenIs(RBRACE)) {
    // ç§»åŠ¨åˆ°é”®
    this.nextToken()

    // è§£æé”®è¡¨è¾¾å¼
    const key = this.parseExpression(Precedence.LOWEST)
    if (!key) {
      return null
    }

    // æœŸæœ›å†’å·
    if (!this.expectPeek(COLON)) {
      return null
    }

    // ç§»åŠ¨åˆ°å€¼
    this.nextToken()

    // è§£æå€¼è¡¨è¾¾å¼
    const value = this.parseExpression(Precedence.LOWEST)
    if (!value) {
      return null
    }

    // å­˜å‚¨é”®å€¼å¯¹
    pairs.set(key, value)

    // å¦‚æœä¸‹ä¸€ä¸ªä¸æ˜¯ }ï¼ŒæœŸæœ›æ˜¯é€—å·
    if (!this.peekTokenIs(RBRACE) && !this.expectPeek(COMMA)) {
      return null
    }
  }

  // æœŸæœ› }
  if (!this.expectPeek(RBRACE)) {
    return null
  }

  return new HashLiteral(token, pairs)
}
```

**è§£æç¤ºä¾‹ï¼š**

```
è¾“å…¥: '{"name": "Monkey", "age": 1}'

Token æµ:
[{] [STRING:name] [:] [STRING:Monkey] [,] [STRING:age] [:] [INT:1] [}]

è§£æè¿‡ç¨‹:
1. curToken = {
2. pairs = new Map()

å¾ªç¯ 1:
  nextToken() â†’ curToken = STRING (name)
  key = StringLiteral("name")
  expectPeek(COLON) â†’ curToken = :
  nextToken() â†’ curToken = STRING (Monkey)
  value = StringLiteral("Monkey")
  pairs.set(StringLiteral("name"), StringLiteral("Monkey"))
  peekToken = COMMA
  expectPeek(COMMA) â†’ curToken = ,

å¾ªç¯ 2:
  nextToken() â†’ curToken = STRING (age)
  key = StringLiteral("age")
  expectPeek(COLON) â†’ curToken = :
  nextToken() â†’ curToken = INT (1)
  value = IntegerLiteral(1)
  pairs.set(StringLiteral("age"), IntegerLiteral(1))
  peekToken = }

é€€å‡ºå¾ªç¯

expectPeek(RBRACE) â†’ curToken = }
è¿”å› HashLiteral
```

#### å¯å“ˆå¸Œå¯¹è±¡

åªæœ‰å®ç°äº† `Hashable` æ¥å£çš„å¯¹è±¡æ‰èƒ½ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ã€‚

```typescript
/**
 * Hashable æ¥å£
 *
 * å¯ä»¥ä½œä¸ºå“ˆå¸Œé”®çš„å¯¹è±¡å¿…é¡»å®ç°æ­¤æ¥å£
 */
export interface Hashable {
  hashKey(): HashKey
}

/**
 * HashKey ç±»
 *
 * å“ˆå¸Œè¡¨å†…éƒ¨ä½¿ç”¨çš„é”®
 */
export class HashKey {
  type: ObjectType
  value: number | string

  constructor(type: ObjectType, value: number | string) {
    this.type = type
    this.value = value
  }

  // ç”Ÿæˆå­—ç¬¦ä¸²å½¢å¼çš„é”®ï¼ˆç”¨äº Mapï¼‰
  toString(): string {
    return `${this.type}:${this.value}`
  }
}
```

**å®ç° Hashableï¼š**

```typescript
// IntegerObject å¯å“ˆå¸Œ
export class IntegerObject implements MonkeyObject, Hashable {
  value: number

  constructor(value: number) {
    this.value = value
  }

  // ...

  hashKey(): HashKey {
    return new HashKey(INTEGER_OBJ, this.value)
  }
}

// StringObject å¯å“ˆå¸Œ
export class StringObject implements MonkeyObject, Hashable {
  value: string

  constructor(value: string) {
    this.value = value
  }

  // ...

  hashKey(): HashKey {
    return new HashKey(STRING_OBJ, this.value)
  }
}

// BooleanObject å¯å“ˆå¸Œ
export class BooleanObject implements MonkeyObject, Hashable {
  value: boolean

  constructor(value: boolean) {
    this.value = value
  }

  // ...

  hashKey(): HashKey {
    const value = this.value ? 1 : 0
    return new HashKey(BOOLEAN_OBJ, value)
  }
}
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

```monkey
// è¿™ä¸¤ä¸ªé”®åº”è¯¥è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„
let hash1 = {5: "five"};
let hash2 = {5: "FIVE"};

// å¦‚æœç›´æ¥ç”¨å¯¹è±¡å¼•ç”¨ä½œä¸ºé”®ï¼š
IntegerObject(5) !== IntegerObject(5)  // ä¸åŒçš„å¯¹è±¡å®ä¾‹

// ä½¿ç”¨ hashKey æ–¹æ³•ï¼š
IntegerObject(5).hashKey() === IntegerObject(5).hashKey()  // true
// å› ä¸ºå®ƒä»¬è¿”å›ç›¸åŒçš„ HashKey { type: "INTEGER", value: 5 }
```

#### æ±‚å€¼å“ˆå¸Œè¡¨å­—é¢é‡

```typescript
/**
 * æ±‚å€¼å“ˆå¸Œè¡¨å­—é¢é‡
 */
function evalHashLiteral(node: HashLiteral, env: Environment): MonkeyObject {
  const pairs = new Map<string, HashPair>()

  // éå†æ‰€æœ‰é”®å€¼å¯¹
  for (const [keyNode, valueNode] of node.pairs) {
    // æ±‚å€¼é”®
    const key = evalNode(keyNode, env)
    if (isError(key)) {
      return key!
    }

    // æ£€æŸ¥é”®æ˜¯å¦å¯å“ˆå¸Œ
    if (!isHashable(key)) {
      return new ErrorObject(`unusable as hash key: ${key!.type()}`)
    }

    // æ±‚å€¼å€¼
    const value = evalNode(valueNode, env)
    if (isError(value)) {
      return value!
    }

    // ç”Ÿæˆå“ˆå¸Œé”®
    const hashed = (key as Hashable).hashKey()
    const hashKeyStr = hashed.toString()

    // å­˜å‚¨é”®å€¼å¯¹
    pairs.set(hashKeyStr, new HashPair(key!, value!))
  }

  return new HashObject(pairs)
}

/**
 * æ£€æŸ¥å¯¹è±¡æ˜¯å¦å¯å“ˆå¸Œ
 */
function isHashable(obj: MonkeyObject | null): obj is Hashable {
  if (!obj) return false
  return 'hashKey' in obj && typeof (obj as any).hashKey === 'function'
}
```

#### å“ˆå¸Œè¡¨æ“ä½œç¤ºä¾‹

```monkey
let person = {"name": "Monkey", "age": 1};

// è®¿é—®å…ƒç´ 
person["name"];    // "Monkey"
person["age"];     // 1

// åµŒå¥—è®¿é—®
let data = {"user": {"name": "John", "age": 30}};
data["user"]["name"];  // "John"

// ä½¿ç”¨æ•°å­—å’Œå¸ƒå°”é”®
let numbers = {1: "one", 2: "two"};
numbers[1];        // "one"

let flags = {true: "yes", false: "no"};
flags[true];       // "yes"
```

### 4.2.3 ç´¢å¼•è¡¨è¾¾å¼

ç´¢å¼•è¡¨è¾¾å¼ç”¨äºè®¿é—®æ•°ç»„å…ƒç´ æˆ–å“ˆå¸Œè¡¨çš„å€¼ã€‚

#### AST è¡¨ç¤º

```typescript
/**
 * IndexExpression ç±»
 *
 * è¡¨ç¤ºç´¢å¼•è®¿é—®è¡¨è¾¾å¼
 * è¯­æ³•ï¼š<expression>[<expression>]
 */
export class IndexExpression implements Expression {
  token: Token // [ token
  left: Expression // è¢«ç´¢å¼•çš„å¯¹è±¡
  index: Expression // ç´¢å¼•å€¼

  constructor(token: Token, left: Expression, index: Expression) {
    this.token = token
    this.left = left
    this.index = index
  }

  expressionNode(): void {}

  tokenLiteral(): string {
    return this.token.Literal
  }

  toString(): string {
    return `(${this.left.toString()}[${this.index.toString()}])`
  }
}
```

#### è§£æç´¢å¼•è¡¨è¾¾å¼

```typescript
/**
 * è§£æç´¢å¼•è¡¨è¾¾å¼
 *
 * è¿™æ˜¯ä¸€ä¸ªä¸­ç¼€è§£æå‡½æ•°ï¼Œleft æ˜¯è¢«ç´¢å¼•çš„è¡¨è¾¾å¼
 */
private parseIndexExpression(left: Expression): Expression | null {
  const token = this.curToken

  // ç§»åŠ¨åˆ°ç´¢å¼•è¡¨è¾¾å¼
  this.nextToken()

  // è§£æç´¢å¼•
  const index = this.parseExpression(Precedence.LOWEST)
  if (!index) {
    return null
  }

  // æœŸæœ› ]
  if (!this.expectPeek(RBRACKET)) {
    return null
  }

  return new IndexExpression(token, left, index)
}
```

**ä¸ºä»€ä¹ˆ `[` æ˜¯ä¸­ç¼€è¿ç®—ç¬¦ï¼Ÿ**

```monkey
arr[0]
^   ^
|   â””â”€â”€ [ æ˜¯ä¸­ç¼€è¿ç®—ç¬¦
â””â”€â”€â”€â”€â”€â”€ å·¦ä¾§è¡¨è¾¾å¼
```

`[` å‡ºç°åœ¨è¡¨è¾¾å¼ä¹‹åï¼Œæ‰€ä»¥å®ƒæ˜¯ä¸­ç¼€è¿ç®—ç¬¦ã€‚

#### æ±‚å€¼ç´¢å¼•è¡¨è¾¾å¼

```typescript
/**
 * æ±‚å€¼ç´¢å¼•è¡¨è¾¾å¼
 */
function evalIndexExpression(
  node: IndexExpression,
  env: Environment
): MonkeyObject {
  // æ±‚å€¼å·¦ä¾§ï¼ˆè¢«ç´¢å¼•çš„å¯¹è±¡ï¼‰
  const left = evalNode(node.left, env)
  if (isError(left)) {
    return left!
  }

  // æ±‚å€¼ç´¢å¼•
  const index = evalNode(node.index, env)
  if (isError(index)) {
    return index!
  }

  // æ ¹æ®å·¦ä¾§å¯¹è±¡ç±»å‹åˆ†æ´¾
  if (left instanceof ArrayObject && index instanceof IntegerObject) {
    return evalArrayIndexExpression(left, index)
  }

  if (left instanceof HashObject) {
    return evalHashIndexExpression(left, index!)
  }

  return new ErrorObject(`index operator not supported: ${left!.type()}`)
}

/**
 * æ±‚å€¼æ•°ç»„ç´¢å¼•
 */
function evalArrayIndexExpression(
  array: ArrayObject,
  index: IntegerObject
): MonkeyObject {
  const idx = index.value
  const max = array.elements.length - 1

  // æ£€æŸ¥ç´¢å¼•èŒƒå›´
  if (idx < 0 || idx > max) {
    return NULL
  }

  return array.elements[idx]
}

/**
 * æ±‚å€¼å“ˆå¸Œç´¢å¼•
 */
function evalHashIndexExpression(
  hash: HashObject,
  index: MonkeyObject
): MonkeyObject {
  // æ£€æŸ¥ç´¢å¼•æ˜¯å¦å¯å“ˆå¸Œ
  if (!isHashable(index)) {
    return new ErrorObject(`unusable as hash key: ${index.type()}`)
  }

  // ç”Ÿæˆå“ˆå¸Œé”®å¹¶æŸ¥æ‰¾
  const hashKey = index.hashKey()
  const hashKeyStr = hashKey.toString()

  const pair = hash.pairs.get(hashKeyStr)
  if (!pair) {
    return NULL
  }

  return pair.value
}
```

**æ‰§è¡Œç¤ºä¾‹ï¼š**

```monkey
let arr = [1, 2, 3];
arr[1];
```

```
1. evalIndexExpression
   left = arr
   index = 1

2. evalNode(arr, env)
   â†’ env.get('arr')
   â†’ ArrayObject([1, 2, 3])

3. evalNode(1, env)
   â†’ IntegerObject(1)

4. evalArrayIndexExpression
   idx = 1
   max = 2
   idx åœ¨èŒƒå›´å†…
   è¿”å› elements[1] = IntegerObject(2)
```

## 4.3 å­—ç¬¦ä¸²æ“ä½œ

### å­—ç¬¦ä¸²æ‹¼æ¥

```typescript
/**
 * æ±‚å€¼å­—ç¬¦ä¸²ä¸­ç¼€è¡¨è¾¾å¼
 */
function evalStringInfixExpression(
  operator: string,
  left: StringObject,
  right: StringObject
): MonkeyObject {
  // åªæ”¯æŒ + è¿ç®—ç¬¦
  if (operator !== '+') {
    return new ErrorObject(
      `unknown operator: ${left.type()} ${operator} ${right.type()}`
    )
  }

  // å­—ç¬¦ä¸²æ‹¼æ¥
  return new StringObject(left.value + right.value)
}
```

### ä½¿ç”¨ç¤ºä¾‹

```monkey
// åŸºæœ¬æ‹¼æ¥
"Hello" + " " + "World";  // "Hello World"

// å˜é‡æ‹¼æ¥
let firstName = "John";
let lastName = "Doe";
let fullName = firstName + " " + lastName;  // "John Doe"

// åœ¨å“ˆå¸Œè¡¨ä¸­ä½¿ç”¨
let greeting = {"hello": "world"};
greeting["hel" + "lo"];  // "world"
```

## 4.4 å†…ç½®å‡½æ•°è¯¦è§£

### 4.4.1 æ•°ç»„æ“ä½œå‡½æ•°

#### len - è·å–é•¿åº¦

```typescript
const lenBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  const arg = args[0]

  // å­—ç¬¦ä¸²é•¿åº¦
  if (arg instanceof StringObject) {
    return new IntegerObject(arg.value.length)
  }

  // æ•°ç»„é•¿åº¦
  if (arg instanceof ArrayObject) {
    return new IntegerObject(arg.elements.length)
  }

  return new ErrorObject(`argument to 'len' not supported, got ${arg.type()}`)
})
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```monkey
len("hello");        // 5
len([1, 2, 3]);      // 3
len([]);             // 0
```

#### first - è·å–ç¬¬ä¸€ä¸ªå…ƒç´ 

```typescript
const firstBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'first' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]

  if (arr.elements.length > 0) {
    return arr.elements[0]
  }

  return NULL
})
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```monkey
first([1, 2, 3]);    // 1
first([]);           // null
```

#### last - è·å–æœ€åä¸€ä¸ªå…ƒç´ 

```typescript
const lastBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'last' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  const length = arr.elements.length

  if (length > 0) {
    return arr.elements[length - 1]
  }

  return NULL
})
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```monkey
last([1, 2, 3]);     // 3
last([]);            // null
```

#### rest - è·å–é™¤ç¬¬ä¸€ä¸ªå¤–çš„å…¶ä½™å…ƒç´ 

```typescript
const restBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 1) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=1`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'rest' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]
  const length = arr.elements.length

  if (length > 0) {
    // åˆ›å»ºæ–°æ•°ç»„ï¼Œä¸ä¿®æ”¹åŸæ•°ç»„
    const newElements = arr.elements.slice(1)
    return new ArrayObject(newElements)
  }

  return NULL
})
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```monkey
rest([1, 2, 3]);     // [2, 3]
rest([1]);           // []
rest([]);            // null
```

**ä¸ºä»€ä¹ˆè¿”å›æ–°æ•°ç»„ï¼Ÿ**

éµå¾ªå‡½æ•°å¼ç¼–ç¨‹çš„ä¸å¯å˜æ€§åŸåˆ™ï¼š

```monkey
let arr = [1, 2, 3];
let tail = rest(arr);
// arr ä»ç„¶æ˜¯ [1, 2, 3]
// tail æ˜¯æ–°æ•°ç»„ [2, 3]
```

#### push - æ·»åŠ å…ƒç´ 

```typescript
const pushBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  if (args.length !== 2) {
    return new ErrorObject(
      `wrong number of arguments. got=${args.length}, want=2`
    )
  }

  if (!(args[0] instanceof ArrayObject)) {
    return new ErrorObject(
      `argument to 'push' must be ARRAY, got ${args[0].type()}`
    )
  }

  const arr = args[0]

  // åˆ›å»ºæ–°æ•°ç»„ï¼Œæ·»åŠ å…ƒç´ 
  const newElements = [...arr.elements, args[1]]
  return new ArrayObject(newElements)
})
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```monkey
let arr = [1, 2, 3];
let newArr = push(arr, 4);
// arr ä»ç„¶æ˜¯ [1, 2, 3]
// newArr æ˜¯ [1, 2, 3, 4]
```

### 4.4.2 è¾“å…¥è¾“å‡ºå‡½æ•°

#### puts - æ‰“å°è¾“å‡º

```typescript
const putsBuiltin = new BuiltinObject((...args: MonkeyObject[]) => {
  for (const arg of args) {
    console.log(arg.inspect())
  }

  return NULL
})
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```monkey
puts("Hello, World!");
// è¾“å‡º: Hello, World!

puts(1, 2, 3);
// è¾“å‡º:
// 1
// 2
// 3

puts([1, 2, 3], {"name": "Monkey"});
// è¾“å‡º:
// [1, 2, 3]
// {name: Monkey}
```

## 4.5 é«˜çº§ç‰¹æ€§

### 4.5.1 é«˜é˜¶å‡½æ•°

é«˜é˜¶å‡½æ•°æ˜¯æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°ã€‚

#### map - æ˜ å°„å‡½æ•°

```monkey
let map = fn(arr, f) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      return accumulated;
    }

    let head = first(arr);
    let tail = rest(arr);

    return iter(tail, push(accumulated, f(head)));
  };

  return iter(arr, []);
};

// ä½¿ç”¨ç¤ºä¾‹
let double = fn(x) { x * 2 };
map([1, 2, 3, 4], double);
// è¿”å›: [2, 4, 6, 8]
```

**æ‰§è¡Œè¿‡ç¨‹ï¼š**

```
map([1, 2, 3], double)

iter([1, 2, 3], [])
â”œâ”€â”€ head = 1, tail = [2, 3]
â”œâ”€â”€ f(1) = 2
â”œâ”€â”€ accumulated = [2]
â””â”€â”€ iter([2, 3], [2])
    â”œâ”€â”€ head = 2, tail = [3]
    â”œâ”€â”€ f(2) = 4
    â”œâ”€â”€ accumulated = [2, 4]
    â””â”€â”€ iter([3], [2, 4])
        â”œâ”€â”€ head = 3, tail = []
        â”œâ”€â”€ f(3) = 6
        â”œâ”€â”€ accumulated = [2, 4, 6]
        â””â”€â”€ iter([], [2, 4, 6])
            â””â”€â”€ è¿”å› [2, 4, 6]
```

#### reduce - å½’çº¦å‡½æ•°

```monkey
let reduce = fn(arr, initial, f) {
  let iter = fn(arr, result) {
    if (len(arr) == 0) {
      return result;
    }

    let head = first(arr);
    let tail = rest(arr);

    return iter(tail, f(result, head));
  };

  return iter(arr, initial);
};

// ä½¿ç”¨ç¤ºä¾‹ï¼šæ±‚å’Œ
let sum = fn(arr) {
  let add = fn(acc, x) { acc + x };
  return reduce(arr, 0, add);
};

sum([1, 2, 3, 4, 5]);  // 15
```

#### filter - è¿‡æ»¤å‡½æ•°

```monkey
let filter = fn(arr, predicate) {
  let iter = fn(arr, accumulated) {
    if (len(arr) == 0) {
      return accumulated;
    }

    let head = first(arr);
    let tail = rest(arr);

    if (predicate(head)) {
      return iter(tail, push(accumulated, head));
    } else {
      return iter(tail, accumulated);
    }
  };

  return iter(arr, []);
};

// ä½¿ç”¨ç¤ºä¾‹ï¼šè¿‡æ»¤å¶æ•°
let isEven = fn(x) { x % 2 == 0 };
filter([1, 2, 3, 4, 5], isEven);
// è¿”å›: [2, 4]
```

**æ³¨æ„ï¼š** Monkey è¯­è¨€ç›®å‰ä¸æ”¯æŒ `%` è¿ç®—ç¬¦ï¼Œè¿™åªæ˜¯ç¤ºä¾‹ã€‚

### 4.5.2 é—­åŒ…åº”ç”¨

#### è®¡æ•°å™¨

```monkey
let newCounter = fn() {
  let count = 0;

  return fn() {
    count = count + 1;
    return count;
  };
};

let counter1 = newCounter();
counter1();  // 1
counter1();  // 2
counter1();  // 3

let counter2 = newCounter();
counter2();  // 1ï¼ˆç‹¬ç«‹çš„è®¡æ•°å™¨ï¼‰
```

#### ç´¯åŠ å™¨å·¥å‚

```monkey
let newAdder = fn(n) {
  return fn(x) { x + n };
};

let addTwo = newAdder(2);
let addTen = newAdder(10);

addTwo(5);   // 7
addTen(5);   // 15
```

#### ç§æœ‰çŠ¶æ€

```monkey
let newPerson = fn(name, age) {
  return {
    "getName": fn() { name },
    "getAge": fn() { age },
    "setAge": fn(newAge) { age = newAge; return age; }
  };
};

let person = newPerson("Alice", 30);
person["getName"]();     // "Alice"
person["getAge"]();      // 30
person["setAge"](31);    // 31
person["getAge"]();      // 31
```

### 4.5.3 é€’å½’æŠ€å·§

#### æ–æ³¢é‚£å¥‘æ•°åˆ—

```monkey
let fibonacci = fn(n) {
  if (n == 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
};

fibonacci(10);  // 55
```

#### é˜¶ä¹˜

```monkey
let factorial = fn(n) {
  if (n == 0) {
    return 1;
  }
  return n * factorial(n - 1);
};

factorial(5);  // 120
```

#### å°¾é€’å½’ä¼˜åŒ–ç‰ˆæœ¬

è™½ç„¶ JavaScript ä¸æ”¯æŒå°¾è°ƒç”¨ä¼˜åŒ–ï¼Œä½†æˆ‘ä»¬å¯ä»¥å†™æˆå°¾é€’å½’å½¢å¼ï¼š

```monkey
let factorialTail = fn(n, acc) {
  if (n == 0) {
    return acc;
  }
  return factorialTail(n - 1, n * acc);
};

let factorial = fn(n) {
  return factorialTail(n, 1);
};

factorial(5);  // 120
```

## 4.6 å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šæ„å»ºé“¾è¡¨

```monkey
// é“¾è¡¨èŠ‚ç‚¹
let node = fn(value, next) {
  return {"value": value, "next": next};
};

// åˆ›å»ºé“¾è¡¨: 1 -> 2 -> 3
let list = node(1, node(2, node(3, null)));

// éå†é“¾è¡¨
let printList = fn(list) {
  if (list == null) {
    return null;
  }

  puts(list["value"]);
  return printList(list["next"]);
};

printList(list);
// è¾“å‡º:
// 1
// 2
// 3
```

### ç¤ºä¾‹ 2ï¼šå®ç° foldï¼ˆæŠ˜å ï¼‰

```monkey
let foldLeft = fn(arr, initial, f) {
  if (len(arr) == 0) {
    return initial;
  }

  let head = first(arr);
  let tail = rest(arr);

  return foldLeft(tail, f(initial, head), f);
};

// æ±‚å’Œ
let sum = fn(arr) {
  let add = fn(a, b) { a + b };
  return foldLeft(arr, 0, add);
};

sum([1, 2, 3, 4, 5]);  // 15

// æ±‚ç§¯
let product = fn(arr) {
  let multiply = fn(a, b) { a * b };
  return foldLeft(arr, 1, multiply);
};

product([1, 2, 3, 4, 5]);  // 120
```

### ç¤ºä¾‹ 3ï¼šå¿«é€Ÿæ’åº

```monkey
let quicksort = fn(arr) {
  if (len(arr) <= 1) {
    return arr;
  }

  let pivot = first(arr);
  let rest = rest(arr);

  // åˆ†åŒº
  let partition = fn(arr, pivot, less, greater) {
    if (len(arr) == 0) {
      return {"less": less, "greater": greater};
    }

    let head = first(arr);
    let tail = rest(arr);

    if (head < pivot) {
      return partition(tail, pivot, push(less, head), greater);
    } else {
      return partition(tail, pivot, less, push(greater, head));
    }
  };

  let parts = partition(rest, pivot, [], []);
  let sortedLess = quicksort(parts["less"]);
  let sortedGreater = quicksort(parts["greater"]);

  // åˆå¹¶
  let concat = fn(a, b) {
    if (len(a) == 0) {
      return b;
    }
    return concat(rest(a), push([first(a)], b));
  };

  return concat(sortedLess, push([pivot], sortedGreater));
};

quicksort([3, 1, 4, 1, 5, 9, 2, 6]);
// è¿”å›: [1, 1, 2, 3, 4, 5, 6, 9]
```

### ç¤ºä¾‹ 4ï¼šå®ç°å¯¹è±¡æ–¹æ³•

```monkey
// åˆ›å»ºä¸€ä¸ª"ç±»"
let newStack = fn() {
  let items = [];

  return {
    "push": fn(item) {
      items = push(items, item);
      return item;
    },
    "pop": fn() {
      if (len(items) == 0) {
        return null;
      }
      let item = last(items);
      // æ³¨æ„ï¼šè¿™é‡Œåº”è¯¥åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
      // ä½† Monkey æ²¡æœ‰å†…ç½®çš„ removeLast å‡½æ•°
      // å®é™…ä½¿ç”¨ä¸­å¯èƒ½éœ€è¦è‡ªå·±å®ç°
      return item;
    },
    "size": fn() {
      return len(items);
    },
    "isEmpty": fn() {
      return len(items) == 0;
    }
  };
};

let stack = newStack();
stack["push"](1);
stack["push"](2);
stack["push"](3);
stack["size"]();      // 3
stack["isEmpty"]();   // false
```

## 4.7 å¯èƒ½çš„æ‰©å±•æ–¹å‘

### è¯­è¨€ç‰¹æ€§æ‰©å±•

#### 1. å¾ªç¯ç»“æ„

```monkey
// while å¾ªç¯
while (x < 10) {
  x = x + 1;
}

// for å¾ªç¯
for (let i = 0; i < 10; i = i + 1) {
  puts(i);
}
```

#### 2. èµ‹å€¼è¡¨è¾¾å¼

```monkey
// é‡æ–°èµ‹å€¼å˜é‡
let x = 5;
x = 10;  // ç›®å‰ä¸æ”¯æŒ
```

#### 3. æ›´å¤šè¿ç®—ç¬¦

```monkey
// å–æ¨¡
5 % 2;  // 1

// æŒ‡æ•°
2 ** 3;  // 8

// é€»è¾‘è¿ç®—ç¬¦
true && false;  // false
true || false;  // true
```

#### 4. è§£æ„

```monkey
// æ•°ç»„è§£æ„
let [a, b, c] = [1, 2, 3];

// å¯¹è±¡è§£æ„
let {name, age} = {"name": "Monkey", "age": 1};
```

#### 5. å±•å¼€è¿ç®—ç¬¦

```monkey
// æ•°ç»„å±•å¼€
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5];  // [1, 2, 3, 4, 5]

// å¯¹è±¡å±•å¼€
let obj1 = {"a": 1, "b": 2};
let obj2 = {...obj1, "c": 3};  // {"a": 1, "b": 2, "c": 3}
```

### å†…ç½®å‡½æ•°æ‰©å±•

#### å­—ç¬¦ä¸²æ“ä½œ

```typescript
// split
split('hello world', ' ') // ["hello", "world"]

// join
join(['hello', 'world'], ' ') // "hello world"

// substr
substr('hello', 0, 2) // "he"
```

#### æ•°ç»„æ“ä½œ

```typescript
// slice
slice([1, 2, 3, 4, 5], 1, 3) // [2, 3]

// concat
concat([1, 2], [3, 4]) // [1, 2, 3, 4]

// reverse
reverse([1, 2, 3]) // [3, 2, 1]
```

#### å¯¹è±¡æ“ä½œ

```typescript
// keys
keys({ a: 1, b: 2 }) // ["a", "b"]

// values
values({ a: 1, b: 2 }) // [1, 2]

// hasKey
hasKey({ a: 1 }, 'a') // true
```

### æ ‡å‡†åº“

å¯ä»¥ç”¨ Monkey æœ¬èº«å®ç°æ ‡å‡†åº“ï¼š

```monkey
// math.monkey
let abs = fn(x) {
  if (x < 0) {
    return -x;
  }
  return x;
};

let max = fn(a, b) {
  if (a > b) { return a; }
  return b;
};

let min = fn(a, b) {
  if (a < b) { return a; }
  return b;
};

// list.monkey
let map = fn(arr, f) { /* ... */ };
let filter = fn(arr, pred) { /* ... */ };
let reduce = fn(arr, init, f) { /* ... */ };
```

## å°ç»“

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬æ‰©å±•äº† Monkey è§£é‡Šå™¨çš„åŠŸèƒ½ï¼š

### æ–°å¢æ•°æ®ç»“æ„

- **æ•°ç»„**ï¼šæœ‰åºé›†åˆï¼Œæ”¯æŒç´¢å¼•è®¿é—®
- **å“ˆå¸Œè¡¨**ï¼šé”®å€¼å¯¹æ˜ å°„ï¼Œæ”¯æŒä»»æ„å¯å“ˆå¸Œç±»å‹ä½œä¸ºé”®
- **ç´¢å¼•è¡¨è¾¾å¼**ï¼šç»Ÿä¸€çš„è¯­æ³•è®¿é—®æ•°ç»„å’Œå“ˆå¸Œè¡¨

### æ–°å¢å†…ç½®å‡½æ•°

- **len**ï¼šè·å–å­—ç¬¦ä¸²æˆ–æ•°ç»„é•¿åº¦
- **first/last**ï¼šè·å–æ•°ç»„çš„ç¬¬ä¸€ä¸ª/æœ€åä¸€ä¸ªå…ƒç´ 
- **rest**ï¼šè·å–æ•°ç»„é™¤ç¬¬ä¸€ä¸ªå…ƒç´ å¤–çš„å…¶ä½™å…ƒç´ 
- **push**ï¼šå‘æ•°ç»„æœ«å°¾æ·»åŠ å…ƒç´ 
- **puts**ï¼šæ‰“å°è¾“å‡º

### é«˜çº§ç¼–ç¨‹æŠ€æœ¯

- **é«˜é˜¶å‡½æ•°**ï¼šmapã€reduceã€filter
- **é—­åŒ…åº”ç”¨**ï¼šè®¡æ•°å™¨ã€ç´¯åŠ å™¨ã€ç§æœ‰çŠ¶æ€
- **é€’å½’æ¨¡å¼**ï¼šæ–æ³¢é‚£å¥‘ã€é˜¶ä¹˜ã€å¿«é€Ÿæ’åº

### è®¾è®¡åŸåˆ™

- **ä¸å¯å˜æ€§**ï¼šå†…ç½®å‡½æ•°è¿”å›æ–°å¯¹è±¡è€Œä¸ä¿®æ”¹åŸå¯¹è±¡
- **å‡½æ•°å¼é£æ ¼**ï¼šé¼“åŠ±ä½¿ç”¨é«˜é˜¶å‡½æ•°å’Œé€’å½’
- **çµæ´»æ€§**ï¼šå“ˆå¸Œè¡¨é”®å¯ä»¥æ˜¯æ•´æ•°ã€å­—ç¬¦ä¸²æˆ–å¸ƒå°”å€¼

Monkey è¯­è¨€è™½ç„¶ç®€å•ï¼Œä½†å·²ç»è¶³å¤Ÿå¼ºå¤§ï¼Œå¯ä»¥å®ç°å¤æ‚çš„ç®—æ³•å’Œæ•°æ®ç»“æ„ã€‚è¿™è¯æ˜äº†ä¸€ä¸ªå¥½çš„è¯­è¨€è®¾è®¡åªéœ€è¦å°‘æ•°å‡ ä¸ªæ ¸å¿ƒç‰¹æ€§ï¼Œå…¶ä½™åŠŸèƒ½å¯ä»¥é€šè¿‡ç»„åˆå®ç°ã€‚

---

**ä¸Šä¸€ç« **ï¼š[ç¬¬ä¸‰ç« ï¼šæ±‚å€¼](./03-æ±‚å€¼.md)

**é™„å½•**ï¼š[å¿«é€Ÿå‚è€ƒ](./appendix.md)

**æºä»£ç å‚è€ƒ**ï¼š

- [ast.ts](../src/monkey/ast/ast.ts) - æ•°ç»„å’Œå“ˆå¸Œè¡¨çš„ AST èŠ‚ç‚¹
- [parser.ts](../src/monkey/parser/parser.ts) - è§£ææ•°ç»„å’Œå“ˆå¸Œè¡¨
- [object.ts](../src/monkey/object/object.ts) - è¿è¡Œæ—¶å¯¹è±¡
- [evaluator.ts](../src/monkey/evaluator/evaluator.ts) - æ±‚å€¼å™¨
- [builtins.ts](../src/monkey/evaluator/builtins.ts) - å†…ç½®å‡½æ•°

**æ¨èé˜…è¯»**ï¼š

- [Little Schemer](https://mitpress.mit.edu/books/little-schemer) - å­¦ä¹ é€’å½’æ€ç»´
- [SICP](https://mitpress.mit.edu/sites/default/files/sicp/index.html) - ç¨‹åºçš„æ„é€ å’Œè§£é‡Š
