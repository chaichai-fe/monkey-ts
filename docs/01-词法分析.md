# 第一章：词法分析

> "程序设计语言的词法分析是将字符序列转换为标记序列的过程。" —— 编译原理

## 目录

- [1.1 词法分析简介](#11-词法分析简介)
  - [1.1.1 什么是词法分析](#111-什么是词法分析)
  - [1.1.2 词法分析器的作用](#112-词法分析器的作用)
  - [1.1.3 词法分析在编译过程中的位置](#113-词法分析在编译过程中的位置)
- [1.2 词法单元（Token）](#12-词法单元token)
  - [1.2.1 Token 的概念](#121-token-的概念)
  - [1.2.2 Token 的分类](#122-token-的分类)
  - [1.2.3 设计 Token 数据结构](#123-设计-token-数据结构)
- [1.3 实现词法分析器](#13-实现词法分析器)
  - [1.3.1 Lexer 的整体架构](#131-lexer-的整体架构)
  - [1.3.2 状态维护和指针移动](#132-状态维护和指针移动)
  - [1.3.3 字符读取机制](#133-字符读取机制)
  - [1.3.4 Token 识别策略](#134-token-识别策略)
  - [1.3.5 处理特殊情况](#135-处理特殊情况)
- [1.4 完整实现详解](#14-完整实现详解)
  - [1.4.1 识别标识符和关键字](#141-识别标识符和关键字)
  - [1.4.2 识别数字字面量](#142-识别数字字面量)
  - [1.4.3 识别字符串字面量](#143-识别字符串字面量)
  - [1.4.4 识别运算符](#144-识别运算符)
  - [1.4.5 处理空白字符](#145-处理空白字符)
- [1.5 测试和调试](#15-测试和调试)
- [1.6 性能优化考虑](#16-性能优化考虑)
- [1.7 扩展和改进](#17-扩展和改进)

---

## 1.1 词法分析简介

### 1.1.1 什么是词法分析

词法分析（Lexical Analysis）是编译器或解释器处理源代码的第一个阶段。它的核心任务是将程序员编写的**字符序列**（源代码）转换为**词法单元序列**（Token 流）。

#### 形象化理解

想象你在阅读一本英文书：

```
"The quick brown fox jumps over the lazy dog."
```

当你阅读这句话时，你的大脑会自动将其分解为单词：

```
["The", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog", "."]
```

词法分析器做的就是类似的工作，只不过它处理的是程序代码。例如：

**输入（源代码字符序列）：**

```
let x = 5 + 5;
```

**输出（词法单元序列）：**

```
[
  { Type: "LET", Literal: "let" },
  { Type: "IDENT", Literal: "x" },
  { Type: "=", Literal: "=" },
  { Type: "INT", Literal: "5" },
  { Type: "+", Literal: "+" },
  { Type: "INT", Literal: "5" },
  { Type: ";", Literal: ";" }
]
```

#### 为什么叫"词法"分析？

"词法"（Lexical）这个术语来源于语言学中的"词汇"（Lexicon）。就像人类语言中的词汇是语言的基本单位一样，编程语言中的词法单元（Token）是程序的基本单位。

### 1.1.2 词法分析器的作用

词法分析器（Lexer，也称为 Scanner 或 Tokenizer）在编译/解释过程中扮演着关键角色：

#### 1. **简化后续阶段的处理**

语法分析器（Parser）不需要处理原始的字符流，而是处理结构化的 Token 流。这大大简化了语法分析的复杂度。

**对比：**

```typescript
// ❌ 如果没有 Lexer，Parser 需要处理：
'l', 'e', 't', ' ', 'x', ' ', '=', ' ', '5', ';'

// ✅ 有了 Lexer，Parser 只需处理：
LET, IDENT, ASSIGN, INT, SEMICOLON
```

#### 2. **提高性能**

通过一次性识别所有字符，避免在后续阶段重复扫描源代码。

#### 3. **及早发现词法错误**

在编译的早期阶段就能发现非法字符、格式错误等问题。

```monkey
let x = 5@3;  // @ 是非法字符，词法分析阶段就能发现
```

#### 4. **实现关注点分离**

将字符级别的处理逻辑与语法级别的处理逻辑分离，使代码更清晰、更易维护。

### 1.1.3 词法分析在编译过程中的位置

词法分析是编译/解释流程的第一步：

```
┌─────────────┐
│  源代码文本  │
│ "let x = 5" │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ 词法分析器   │  ◄── 本章内容
│   (Lexer)   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  Token 流   │
│ [LET, IDENT,│
│  ASSIGN,INT]│
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ 语法分析器   │
│  (Parser)   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  抽象语法树  │
│    (AST)    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   求值器     │
│ (Evaluator) │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  执行结果    │
└─────────────┘
```

## 1.2 词法单元（Token）

### 1.2.1 Token 的概念

Token（词法单元）是源代码中**具有独立意义的最小单位**。它是词法分析的输出单位，也是语法分析的输入单位。

#### Token 的组成

每个 Token 通常包含两个核心信息：

1. **类型（Type）**：表明这是什么类型的 Token
2. **字面量（Literal）**：Token 在源代码中的原始文本

#### 为什么需要 Token？

直接处理字符流存在以下问题：

```typescript
// 问题 1：歧义性
'==' // 这是两个 '=' 还是一个 '=='？

// 问题 2：复杂性
'123' // 需要多次判断才能确定这是一个完整的数字

// 问题 3：效率问题
'let' // 需要读取 3 个字符才能确定这是关键字
```

Token 解决了这些问题，提供了清晰、明确的抽象。

### 1.2.2 Token 的分类

在 Monkey 语言中，Token 可以分为以下几类：

#### 1. **特殊 Token**

```typescript
ILLEGAL // 非法/无法识别的字符
EOF // 文件结束标记（End Of File）
```

**用途说明：**

- `ILLEGAL`：用于标记词法分析器无法识别的字符，帮助报告错误
- `EOF`：标记输入结束，告诉 Parser 不需要再请求更多 Token

#### 2. **标识符和字面量**

```typescript
IDENT // 标识符（变量名、函数名）：x, foo, myVariable
INT // 整数字面量：42, 0, -10
STRING // 字符串字面量："hello", "world"
```

**示例：**

```monkey
let myAge = 25;
//  ^^^^^   ^^
//  IDENT   INT

let message = "Hello";
//  ^^^^^^^   ^^^^^^^
//  IDENT     STRING
```

#### 3. **运算符**

运算符用于表示各种操作：

```typescript
// 算术运算符
PLUS // +  加法
MINUS // -  减法（也用作负号）
ASTERISK // *  乘法
SLASH // /  除法

// 比较运算符
LT // <  小于
GT // >  大于
EQ // == 等于
NOT_EQ // != 不等于

// 逻辑运算符
BANG // !  逻辑非

// 赋值运算符
ASSIGN // =  赋值
```

**为什么区分 `=` 和 `==`？**

```monkey
let x = 5;    // = 是赋值
x == 5;       // == 是比较
```

这是两个完全不同的操作，必须在词法层面就区分清楚。

#### 4. **分隔符**

分隔符用于分隔和组织代码结构：

```typescript
COMMA // ,  分隔参数、数组元素
SEMICOLON // ;  语句结束标记
COLON // :  哈希表键值对分隔

LPAREN // (  左圆括号 - 函数调用、分组
RPAREN // )  右圆括号
LBRACE // {  左花括号 - 代码块、哈希表
RBRACE // }  右花括号
LBRACKET // [  左方括号 - 数组、索引
RBRACKET // ]  右方括号
```

**配对使用：**

```monkey
fn(x, y) { return x + y; }
// ^    ^   ^            ^
// (与)配对 {与}配对

let arr = [1, 2, 3];
//        ^       ^
//        [与]配对
```

#### 5. **关键字**

关键字是语言的保留字，具有特殊含义：

```typescript
FUNCTION // fn      函数定义
LET // let     变量声明
TRUE // true    布尔真值
FALSE // false   布尔假值
IF // if      条件判断
ELSE // else    条件分支
RETURN // return  返回语句
```

**关键字 vs 标识符：**

```monkey
let let = 5;     // ❌ 错误：let 是关键字，不能作为变量名
let myLet = 5;   // ✅ 正确：myLet 是标识符
```

### 1.2.3 设计 Token 数据结构

#### TypeScript 接口定义

```typescript
/**
 * Token 接口
 *
 * 表示源代码中的一个词法单元
 */
export interface Token {
  Type: TokenType // Token 的类型
  Literal: string // Token 的原始文本
}

/**
 * TokenType 类型
 *
 * 使用字符串类型来表示所有可能的 Token 类型
 * 这样可以直接用字符串比较，简化实现
 */
export type TokenType = string
```

#### 为什么使用接口而不是类？

```typescript
// ✅ 使用接口：轻量级，只存储数据
interface Token {
  Type: TokenType
  Literal: string
}

// ❌ 使用类：会增加不必要的开销
class Token {
  constructor(public Type: TokenType, public Literal: string) {}
  // 每个实例都会携带方法，占用更多内存
}
```

Token 是纯数据结构，不需要方法，使用接口更合适。

#### Token 类型常量定义

```typescript
// 特殊类型
export const ILLEGAL = 'ILLEGAL'
export const EOF = 'EOF'

// 标识符和字面量
export const IDENT = 'IDENT'
export const INT = 'INT'
export const STRING = 'STRING'

// 运算符
export const ASSIGN = '='
export const PLUS = '+'
export const MINUS = '-'
export const BANG = '!'
export const ASTERISK = '*'
export const SLASH = '/'
export const LT = '<'
export const GT = '>'
export const EQ = '=='
export const NOT_EQ = '!='

// 分隔符
export const COMMA = ','
export const SEMICOLON = ';'
export const COLON = ':'
export const LPAREN = '('
export const RPAREN = ')'
export const LBRACE = '{'
export const RBRACE = '}'
export const LBRACKET = '['
export const RBRACKET = ']'

// 关键字
export const FUNCTION = 'FUNCTION'
export const LET = 'LET'
export const TRUE = 'TRUE'
export const FALSE = 'FALSE'
export const IF = 'IF'
export const ELSE = 'ELSE'
export const RETURN = 'RETURN'
```

**为什么用常量？**

1. **类型安全**：防止拼写错误
2. **代码提示**：IDE 可以自动补全
3. **重构友好**：修改一处，全局生效

#### 关键字查找表

为了区分关键字和普通标识符，我们需要一个查找表：

```typescript
/**
 * 关键字映射表
 *
 * 将关键字字符串映射到对应的 TokenType
 * 用于判断一个标识符是否为关键字
 */
const keywords: Record<string, TokenType> = {
  fn: FUNCTION,
  let: LET,
  true: TRUE,
  false: FALSE,
  if: IF,
  else: ELSE,
  return: RETURN,
}

/**
 * 查找标识符的类型
 *
 * @param ident - 要查找的标识符字符串
 * @returns 如果是关键字，返回对应的 TokenType；否则返回 IDENT
 *
 * @example
 * lookupIdent('let')     // => 'LET'
 * lookupIdent('myVar')   // => 'IDENT'
 */
export function lookupIdent(ident: string): TokenType {
  const tokenType = keywords[ident]
  return tokenType !== undefined ? tokenType : IDENT
}
```

**工作原理：**

```typescript
// 场景 1：关键字
const token1 = lookupIdent('let')
// keywords['let'] = 'LET'
// tokenType = 'LET'
// 返回 'LET'

// 场景 2：普通标识符
const token2 = lookupIdent('myVariable')
// keywords['myVariable'] = undefined
// tokenType = undefined
// 返回 'IDENT'
```

## 1.3 实现词法分析器

### 1.3.1 Lexer 的整体架构

词法分析器的核心是 `Lexer` 类，它维护了扫描源代码所需的所有状态信息。

#### 类结构设计

```typescript
/**
 * Lexer 类
 *
 * 词法分析器的核心实现
 * 负责将源代码字符串转换为 Token 流
 */
export class Lexer {
  private input: string // 输入的源代码字符串
  private position: number // 当前位置（指向当前字符）
  private readPosition: number // 读取位置（指向下一个字符）
  private ch: string // 当前字符

  /**
   * 构造函数
   *
   * @param input - 要分析的源代码字符串
   */
  constructor(input: string) {
    this.input = input
    this.position = 0
    this.readPosition = 0
    this.ch = ''

    // 初始化：读取第一个字符
    this.readChar()
  }

  /**
   * 获取下一个 Token
   *
   * 这是 Lexer 的主要接口
   * 每次调用返回下一个 Token，直到 EOF
   *
   * @returns 识别出的 Token
   */
  public nextToken(): Token {
    // 实现细节...
  }

  // 私有辅助方法...
}
```

#### 为什么需要两个位置指针？

```
源代码: "let x = 5;"

位置:    0123456789

初始状态:
input:       l e t   x   =   5 ;
position:    ↑
readPosition:  ↑
ch:          'l'

这种设计的优势：
1. position 指向当前正在处理的字符
2. readPosition 指向下一个要读取的字符
3. 可以方便地"预读"（lookahead）下一个字符
```

**预读的重要性：**

```typescript
// 判断 '=' 还是 '=='
if (ch === '=') {
  if (peekChar() === '=') {
    // 预读下一个字符
    // 这是 '=='
  } else {
    // 这是 '='
  }
}
```

### 1.3.2 状态维护和指针移动

#### readChar 方法详解

```typescript
/**
 * 读取下一个字符
 *
 * 这是 Lexer 的核心方法之一
 * 负责移动位置指针并更新当前字符
 *
 * 工作流程：
 * 1. 检查是否到达输入末尾
 * 2. 如果未到末尾，读取 readPosition 位置的字符
 * 3. 更新 position 为当前位置
 * 4. 更新 readPosition 为下一个位置
 */
private readChar(): void {
  // 检查是否已经读取到末尾
  if (this.readPosition >= this.input.length) {
    // 使用空字符串表示 EOF
    // 注意：这里不使用 \0 或特殊字符，而是空字符串
    this.ch = '';
  } else {
    // 读取下一个字符
    this.ch = this.input[this.readPosition];
  }

  // 移动位置指针
  this.position = this.readPosition;
  this.readPosition += 1;
}
```

**执行过程可视化：**

```
输入: "let"

┌─────────┬─────────┬─────────┬─────────┐
│ Index   │    0    │    1    │    2    │
├─────────┼─────────┼─────────┼─────────┤
│ Char    │   'l'   │   'e'   │   't'   │
└─────────┴─────────┴─────────┴─────────┘

初始化后（调用一次 readChar）：
position: 0, readPosition: 1, ch: 'l'
          ↑                ↑

再次调用 readChar：
position: 1, readPosition: 2, ch: 'e'
                   ↑                ↑

再次调用 readChar：
position: 2, readPosition: 3, ch: 't'
                            ↑                ↑

再次调用 readChar：
position: 3, readPosition: 4, ch: ''
                                     ↑                ↑
                                     (超出范围，ch 为空字符串)
```

#### peekChar 方法详解

```typescript
/**
 * 查看下一个字符但不移动指针
 *
 * 这是实现"预读"（lookahead）的关键方法
 * 用于判断多字符 Token（如 '==' 和 '!='）
 *
 * @returns 下一个字符，如果已到末尾则返回空字符串
 *
 * 注意：这个方法不会改变任何状态
 */
private peekChar(): string {
  // 检查下一个位置是否超出范围
  if (this.readPosition >= this.input.length) {
    return '';
  }

  // 返回下一个字符，但不移动指针
  return this.input[this.readPosition];
}
```

**使用示例：**

```typescript
// 处理 '=' 和 '=='
if (this.ch === '=') {
  if (this.peekChar() === '=') {
    // 保存当前字符
    const firstChar = this.ch

    // 移动到下一个字符
    this.readChar()

    // 组合成 '=='
    const literal = firstChar + this.ch
    return { Type: EQ, Literal: literal }
  } else {
    // 只是单个 '='
    return { Type: ASSIGN, Literal: '=' }
  }
}
```

### 1.3.3 字符读取机制

#### 处理空白字符

```typescript
/**
 * 跳过空白字符
 *
 * 空白字符包括：
 * - 空格 (' ')
 * - 制表符 ('\t')
 * - 换行符 ('\n')
 * - 回车符 ('\r')
 *
 * 这些字符在 Monkey 语言中没有语法意义
 * 只用于分隔 Token
 */
private skipWhitespace(): void {
  while (
    this.ch === ' ' ||
    this.ch === '\t' ||
    this.ch === '\n' ||
    this.ch === '\r'
  ) {
    this.readChar();
  }
}
```

**为什么要跳过空白字符？**

```monkey
// 以下两种写法在语义上完全相同：
let x=5;
let    x    =    5   ;

// 空白字符只是为了提高可读性，不影响程序语义
```

**执行过程：**

```
输入: "let   x"
       012345678

开始位置: position=3, ch=' '

while (ch === ' '):
  readChar()  // position=4, ch=' '

while (ch === ' '):
  readChar()  // position=5, ch=' '

while (ch === ' '):
  readChar()  // position=6, ch='x'

while (ch === ' '): false, 退出循环

结果: position=6, ch='x' (跳过了所有空格)
```

### 1.3.4 Token 识别策略

#### nextToken 方法的整体结构

```typescript
/**
 * 获取下一个 Token
 *
 * 这是词法分析器的核心方法
 * 使用有限状态机的思想来识别不同类型的 Token
 *
 * @returns 识别出的 Token
 */
public nextToken(): Token {
  let tok: Token;

  // 第一步：跳过所有空白字符
  this.skipWhitespace();

  // 第二步：根据当前字符判断 Token 类型
  switch (this.ch) {
    // 单字符 Token...
    // 可能的多字符 Token...
    // 字面量...
    // 默认情况...
  }

  // 第三步：移动到下一个字符
  this.readChar();

  return tok;
}
```

**有限状态机思想：**

```
输入字符 → 判断类型 → 采取行动 → 返回 Token

例如：
'(' → 单字符Token → 创建 LPAREN Token → 返回
'=' → 可能多字符 → 检查下一个字符 → 返回 ASSIGN 或 EQ
'5' → 数字开始 → 读取完整数字 → 返回 INT Token
'a' → 字母开始 → 读取完整标识符 → 返回 IDENT Token
```

## 1.4 完整实现详解

### 1.4.1 识别标识符和关键字

#### 读取标识符

```typescript
/**
 * 读取标识符
 *
 * 从当前位置开始，读取连续的字母和下划线
 * 直到遇到非标识符字符为止
 *
 * 标识符规则：
 * - 第一个字符必须是字母或下划线
 * - 后续字符可以是字母、数字或下划线
 *
 * @returns 读取到的标识符字符串
 */
private readIdentifier(): string {
  // 记录标识符的起始位置
  const startPosition = this.position;

  // 持续读取字母或下划线
  while (isLetter(this.ch)) {
    this.readChar();
  }

  // 返回从起始位置到当前位置的子字符串
  return this.input.slice(startPosition, this.position);
}

/**
 * 判断字符是否为字母或下划线
 *
 * 在 Monkey 语言中，标识符可以包含：
 * - 小写字母 a-z
 * - 大写字母 A-Z
 * - 下划线 _
 *
 * @param ch - 要判断的字符
 * @returns 如果是有效的标识符字符返回 true
 */
function isLetter(ch: string): boolean {
  return (
    ('a' <= ch && ch <= 'z') ||
    ('A' <= ch && ch <= 'Z') ||
    ch === '_'
  );
}
```

**执行过程示例：**

```
输入: "myVariable123 = 5"

初始状态: position=0, ch='m'

调用 readIdentifier():
  startPosition = 0

  while (isLetter('m')): true
    readChar() → position=1, ch='y'

  while (isLetter('y')): true
    readChar() → position=2, ch='V'

  while (isLetter('V')): true
    readChar() → position=3, ch='a'

  ... 继续直到 ...

  while (isLetter('e')): true
    readChar() → position=10, ch='1'

  while (isLetter('1')): false (数字不是字母)
    退出循环

  返回 input.slice(0, 10) = "myVariable"

注意：读取停止在第一个非字母字符，但不消费它
```

#### 在 nextToken 中使用

```typescript
public nextToken(): Token {
  let tok: Token;
  this.skipWhitespace();

  switch (this.ch) {
    // ... 其他情况 ...

    default:
      // 检查是否是标识符的开始
      if (isLetter(this.ch)) {
        const literal = this.readIdentifier();

        // 查找是关键字还是普通标识符
        const tokenType = lookupIdent(literal);

        // ⚠️ 注意：这里直接返回，不调用 readChar()
        // 因为 readIdentifier() 已经移动了指针
        return { Type: tokenType, Literal: literal };
      }

      // ... 其他情况 ...
  }

  this.readChar();
  return tok;
}
```

**为什么直接返回不调用 readChar()？**

```
readIdentifier() 的副作用：
- 它会移动 position 到标识符之后的第一个字符
- 如果再调用 readChar()，会跳过一个字符

错误示例：
输入: "let x"
调用 readIdentifier() → 返回 "let", position 在 ' ' (空格)
如果调用 readChar() → position 移到 'x'
结果：跳过了空格，可能导致错误！

正确做法：
readIdentifier() 后直接返回，不调用 readChar()
```

### 1.4.2 识别数字字面量

#### 读取数字

```typescript
/**
 * 读取数字
 *
 * 从当前位置开始，读取连续的数字字符
 *
 * 当前实现只支持整数
 * 不支持：浮点数、科学计数法、十六进制等
 *
 * @returns 读取到的数字字符串
 */
private readNumber(): string {
  // 记录数字的起始位置
  const startPosition = this.position;

  // 持续读取数字字符
  while (isDigit(this.ch)) {
    this.readChar();
  }

  // 返回从起始位置到当前位置的子字符串
  return this.input.slice(startPosition, this.position);
}

/**
 * 判断字符是否为数字
 *
 * @param ch - 要判断的字符
 * @returns 如果是数字字符（0-9）返回 true
 */
function isDigit(ch: string): boolean {
  return '0' <= ch && ch <= '9';
}
```

**执行过程示例：**

```
输入: "123 + 456"

初始状态: position=0, ch='1'

调用 readNumber():
  startPosition = 0

  while (isDigit('1')): true
    readChar() → position=1, ch='2'

  while (isDigit('2')): true
    readChar() → position=2, ch='3'

  while (isDigit('3')): true
    readChar() → position=3, ch=' '

  while (isDigit(' ')): false
    退出循环

  返回 input.slice(0, 3) = "123"
```

#### 在 nextToken 中使用

```typescript
public nextToken(): Token {
  let tok: Token;
  this.skipWhitespace();

  switch (this.ch) {
    // ... 其他情况 ...

    default:
      if (isLetter(this.ch)) {
        // ... 处理标识符 ...
      } else if (isDigit(this.ch)) {
        // 读取完整的数字
        const literal = this.readNumber();

        // ⚠️ 注意：同样直接返回，不调用 readChar()
        return { Type: INT, Literal: literal };
      } else {
        // 无法识别的字符
        tok = newToken(ILLEGAL, this.ch);
      }
  }

  this.readChar();
  return tok;
}
```

**扩展思考：如何支持浮点数？**

```typescript
// 可能的实现思路：
private readNumber(): string {
  const startPosition = this.position;

  // 读取整数部分
  while (isDigit(this.ch)) {
    this.readChar();
  }

  // 检查是否有小数点
  if (this.ch === '.' && isDigit(this.peekChar())) {
    this.readChar(); // 跳过小数点

    // 读取小数部分
    while (isDigit(this.ch)) {
      this.readChar();
    }
  }

  return this.input.slice(startPosition, this.position);
}
```

### 1.4.3 识别字符串字面量

#### 读取字符串

```typescript
/**
 * 读取字符串字面量
 *
 * 字符串由双引号包围："hello world"
 *
 * 当前实现不支持：
 * - 转义字符（\n, \t, \"等）
 * - 多行字符串
 * - 单引号字符串
 *
 * @returns 字符串内容（不包括引号）
 */
private readString(): string {
  // 跳过开始的引号，从下一个字符开始
  const startPosition = this.position + 1;

  // 读取字符直到遇到结束引号或文件末尾
  while (true) {
    this.readChar();

    // 结束条件：
    // 1. 遇到结束引号
    // 2. 到达文件末尾
    if (this.ch === '"' || this.ch === '') {
      break;
    }
  }

  // 返回引号之间的内容
  return this.input.slice(startPosition, this.position);
}
```

**执行过程示例：**

```
输入: '"Hello, World!" + '

初始状态: position=0, ch='"'

调用 readString():
  startPosition = 0 + 1 = 1 (跳过开始的引号)

  while (true):
    readChar() → position=1, ch='H'
    if (ch === '"' || ch === ''): false, 继续

  while (true):
    readChar() → position=2, ch='e'
    if (ch === '"' || ch === ''): false, 继续

  ... 继续直到 ...

  while (true):
    readChar() → position=14, ch='"'
    if (ch === '"' || ch === ''): true, 退出循环

  返回 input.slice(1, 14) = "Hello, World!"

注意：
- 返回的字符串不包括引号
- position 停在结束引号上
```

#### 在 nextToken 中使用

```typescript
public nextToken(): Token {
  let tok: Token;
  this.skipWhitespace();

  switch (this.ch) {
    case '"':
      // 读取字符串字面量
      tok = {
        Type: STRING,
        Literal: this.readString(),
      };
      break;

    // ... 其他情况 ...
  }

  this.readChar();
  return tok;
}
```

**扩展思考：如何支持转义字符？**

```typescript
private readString(): string {
  const startPosition = this.position + 1;
  let result = '';

  while (true) {
    this.readChar();

    if (this.ch === '"' || this.ch === '') {
      break;
    }

    // 处理转义字符
    if (this.ch === '\\') {
      this.readChar(); // 读取转义字符后的字符

      switch (this.ch) {
        case 'n':
          result += '\n';
          break;
        case 't':
          result += '\t';
          break;
        case '"':
          result += '"';
          break;
        case '\\':
          result += '\\';
          break;
        default:
          result += '\\' + this.ch;
      }
    } else {
      result += this.ch;
    }
  }

  return result;
}
```

### 1.4.4 识别运算符

#### 单字符运算符

```typescript
public nextToken(): Token {
  let tok: Token;
  this.skipWhitespace();

  switch (this.ch) {
    case '+':
      tok = newToken(PLUS, this.ch);
      break;

    case '-':
      tok = newToken(MINUS, this.ch);
      break;

    case '*':
      tok = newToken(ASTERISK, this.ch);
      break;

    case '/':
      tok = newToken(SLASH, this.ch);
      break;

    case '<':
      tok = newToken(LT, this.ch);
      break;

    case '>':
      tok = newToken(GT, this.ch);
      break;

    // ... 更多运算符 ...
  }

  this.readChar();
  return tok;
}

/**
 * 创建一个新的 Token
 *
 * 辅助函数，简化 Token 的创建
 *
 * @param tokenType - Token 的类型
 * @param ch - 字符
 * @returns Token 对象
 */
function newToken(tokenType: TokenType, ch: string): Token {
  return { Type: tokenType, Literal: ch };
}
```

#### 多字符运算符（预读技术）

处理 `==` 和 `!=` 这种多字符运算符是词法分析的一个难点。

```typescript
public nextToken(): Token {
  let tok: Token;
  this.skipWhitespace();

  switch (this.ch) {
    case '=':
      // 预读下一个字符，判断是 '=' 还是 '=='
      if (this.peekChar() === '=') {
        // 保存当前字符
        const ch = this.ch;

        // 移动到下一个字符
        this.readChar();

        // 组合成 '=='
        const literal = ch + this.ch;

        // 创建 EQ Token
        tok = { Type: EQ, Literal: literal };
      } else {
        // 只是单个 '='
        tok = newToken(ASSIGN, this.ch);
      }
      break;

    case '!':
      // 预读下一个字符，判断是 '!' 还是 '!='
      if (this.peekChar() === '=') {
        const ch = this.ch;
        this.readChar();
        const literal = ch + this.ch;
        tok = { Type: NOT_EQ, Literal: literal };
      } else {
        tok = newToken(BANG, this.ch);
      }
      break;

    // ... 其他情况 ...
  }

  this.readChar();
  return tok;
}
```

**执行过程可视化：**

```
场景 1：处理 "=="

输入: "x == 5"
       01234

position=2, ch='='

执行 nextToken():
  case '=':
    peekChar() = input[readPosition] = input[3] = '='

    if (peekChar() === '='): true
      ch = '='  // 保存第一个 '='
      readChar() → position=3, ch='='
      literal = '=' + '=' = '=='
      tok = { Type: 'EQ', Literal: '==' }

  readChar() → position=4, ch=' '
  return tok

结果：返回 { Type: 'EQ', Literal: '==' }

---

场景 2：处理 "= ="（有空格）

输入: "x = = 5"
       012345

position=2, ch='='

执行 nextToken():
  case '=':
    peekChar() = input[readPosition] = input[3] = ' '

    if (peekChar() === '='): false
      tok = newToken(ASSIGN, '=')
      tok = { Type: '=', Literal: '=' }

  readChar() → position=3, ch=' '
  return tok

结果：返回 { Type: '=', Literal: '=' }
(下次调用会返回另一个 '=')
```

### 1.4.5 处理空白字符

空白字符包括空格、制表符、换行符和回车符。这些字符在大多数情况下对程序语义没有影响，只是用于分隔 Token。

```typescript
/**
 * 跳过空白字符
 *
 * 持续读取字符直到遇到非空白字符
 *
 * 空白字符定义：
 * - ' '  空格
 * - '\t' 制表符（Tab）
 * - '\n' 换行符（LF - Line Feed）
 * - '\r' 回车符（CR - Carriage Return）
 */
private skipWhitespace(): void {
  while (
    this.ch === ' ' ||
    this.ch === '\t' ||
    this.ch === '\n' ||
    this.ch === '\r'
  ) {
    this.readChar();
  }
}
```

**为什么换行符对某些语言很重要？**

在某些语言中（如 Python、Go），换行符具有语法意义：

```python
# Python 中换行是语句结束的标志
x = 5
y = 10

# Monkey 中换行只是空白字符
x = 5
y = 10
# 等同于 x = 5 y = 10（但这会导致语法错误）
```

Monkey 使用分号作为语句结束标志（虽然分号是可选的），所以换行符可以被视为普通空白字符。

## 1.5 测试和调试

### 测试用例设计

```typescript
import { describe, it, expect } from 'vitest'
import { Lexer } from './lexer'
import * as token from '../token/token'

describe('Lexer', () => {
  it('应该正确识别单字符 Token', () => {
    const input = '=+(){},;'
    const lexer = new Lexer(input)

    const tests = [
      { expectedType: token.ASSIGN, expectedLiteral: '=' },
      { expectedType: token.PLUS, expectedLiteral: '+' },
      { expectedType: token.LPAREN, expectedLiteral: '(' },
      { expectedType: token.RPAREN, expectedLiteral: ')' },
      { expectedType: token.LBRACE, expectedLiteral: '{' },
      { expectedType: token.RBRACE, expectedLiteral: '}' },
      { expectedType: token.COMMA, expectedLiteral: ',' },
      { expectedType: token.SEMICOLON, expectedLiteral: ';' },
      { expectedType: token.EOF, expectedLiteral: '' },
    ]

    for (const tt of tests) {
      const tok = lexer.nextToken()
      expect(tok.Type).toBe(tt.expectedType)
      expect(tok.Literal).toBe(tt.expectedLiteral)
    }
  })

  it('应该正确识别完整的 Monkey 程序', () => {
    const input = `
      let five = 5;
      let ten = 10;
      
      let add = fn(x, y) {
        x + y;
      };
      
      let result = add(five, ten);
    `

    const lexer = new Lexer(input)

    const tests = [
      { expectedType: token.LET, expectedLiteral: 'let' },
      { expectedType: token.IDENT, expectedLiteral: 'five' },
      { expectedType: token.ASSIGN, expectedLiteral: '=' },
      { expectedType: token.INT, expectedLiteral: '5' },
      { expectedType: token.SEMICOLON, expectedLiteral: ';' },
      // ... 更多测试用例
    ]

    for (const tt of tests) {
      const tok = lexer.nextToken()
      expect(tok.Type).toBe(tt.expectedType)
      expect(tok.Literal).toBe(tt.expectedLiteral)
    }
  })

  it('应该正确处理多字符运算符', () => {
    const input = '== != = !'
    const lexer = new Lexer(input)

    const tests = [
      { expectedType: token.EQ, expectedLiteral: '==' },
      { expectedType: token.NOT_EQ, expectedLiteral: '!=' },
      { expectedType: token.ASSIGN, expectedLiteral: '=' },
      { expectedType: token.BANG, expectedLiteral: '!' },
    ]

    for (const tt of tests) {
      const tok = lexer.nextToken()
      expect(tok.Type).toBe(tt.expectedType)
      expect(tok.Literal).toBe(tt.expectedLiteral)
    }
  })

  it('应该正确识别字符串字面量', () => {
    const input = '"hello world" "foo bar"'
    const lexer = new Lexer(input)

    const tests = [
      { expectedType: token.STRING, expectedLiteral: 'hello world' },
      { expectedType: token.STRING, expectedLiteral: 'foo bar' },
    ]

    for (const tt of tests) {
      const tok = lexer.nextToken()
      expect(tok.Type).toBe(tt.expectedType)
      expect(tok.Literal).toBe(tt.expectedLiteral)
    }
  })

  it('应该能处理非法字符', () => {
    const input = 'let x = @;'
    const lexer = new Lexer(input)

    lexer.nextToken() // LET
    lexer.nextToken() // IDENT
    lexer.nextToken() // ASSIGN

    const illegalTok = lexer.nextToken()
    expect(illegalTok.Type).toBe(token.ILLEGAL)
    expect(illegalTok.Literal).toBe('@')
  })
})
```

## 1.6 性能优化考虑

### 1. 避免字符串拼接

```typescript
// ❌ 不好：多次字符串拼接
let result = ''
for (let i = 0; i < this.input.length; i++) {
  result += this.input[i]
}

// ✅ 好：使用 slice
const result = this.input.slice(startPosition, this.position)
```

### 2. 缓存常用 Token

```typescript
// 对于经常出现的 Token，可以预先创建
const LPAREN_TOKEN: Token = { Type: LPAREN, Literal: '(' };
const RPAREN_TOKEN: Token = { Type: RPAREN, Literal: ')' };
// ... 更多

// 在 nextToken 中直接返回
case '(':
  tok = LPAREN_TOKEN;
  break;
```

### 3. 使用 Map 而不是 Object

```typescript
// ✅ 使用 Map（性能更好）
const keywords = new Map<string, TokenType>([
  ['fn', FUNCTION],
  ['let', LET],
  // ...
])

// 查找
keywords.get(ident)
```

## 1.7 扩展和改进

### 1. 支持注释

```typescript
private skipComment(): void {
  if (this.ch === '/' && this.peekChar() === '/') {
    // 单行注释，读取到行尾
    while (this.ch !== '\n' && this.ch !== '') {
      this.readChar();
    }
  }
}
```

### 2. 支持更多数字格式

```typescript
// 十六进制
if (this.ch === '0' && this.peekChar() === 'x') {
  return this.readHexNumber()
}

// 二进制
if (this.ch === '0' && this.peekChar() === 'b') {
  return this.readBinaryNumber()
}
```

### 3. 改进错误报告

```typescript
class Token {
  Type: TokenType
  Literal: string
  Line: number // 添加行号
  Column: number // 添加列号
}
```

## 小结

在本章中，我们深入学习了：

### 核心概念

- **词法分析的定义**：将字符序列转换为 Token 序列
- **Token 的本质**：源代码中有意义的最小单位
- **词法分析器的作用**：简化后续处理、提高性能、及早发现错误

### 实现技术

- **状态维护**：position 和 readPosition 的双指针技术
- **预读技术**：peekChar 方法处理多字符 Token
- **字符分类**：isLetter 和 isDigit 辅助函数
- **策略模式**：根据字符类型采用不同的识别策略

### 设计原则

- **单一职责**：每个方法只负责一个任务
- **关注点分离**：字符处理与 Token 生成分离
- **可扩展性**：易于添加新的 Token 类型

### 测试要点

- 单字符 Token 识别
- 多字符 Token 识别
- 关键字与标识符区分
- 边界条件处理
- 错误情况处理

词法分析器是解释器的基础，为后续的语法分析提供了清晰、结构化的输入。掌握词法分析的原理和实现，是理解编译器工作原理的第一步。

---

**下一章**：[第二章：语法分析](./02-语法分析.md)

在下一章中，我们将学习如何使用 Parser 将 Token 流转换为抽象语法树（AST），这是理解程序结构的关键步骤。

**源代码参考**：

- [token.ts](../src/monkey/token/token.ts) - Token 定义
- [lexer.ts](../src/monkey/lexer/lexer.ts) - Lexer 实现
- [lexer.test.ts](../src/monkey/lexer/lexer.test.ts) - 测试用例

**推荐阅读**：

- 《编译原理》（龙书）第 3 章：词法分析
- 《现代编译原理》第 2 章：词法分析
